swagger: "2.0"
info:
  description: "To run API, use `--api-addr=yourserver:3000` CLI argument or enable it in config file"
  version: "1.0.0"
  title: "rportd HTTP(S) API"
host: "yourserver:3000"
basePath: "/api/v1"
securityDefinitions:
  basic_auth:
    type: basic
    description: "HTTP-basic authentication works for all routes. You can use user's password only when 2FA is not enabled. For scripting you can use long-lived API token generated using /me/token endpoint instead of the password."
  bearer_auth:
    description: "Instead of HTTP basic authentication you can retrieve a bearer token using /login endpoint. Send the retrieved token in 'Authorization: Bearer <TOKEN>' header. If 2FA is enabled, the bearer token from /login endpoint can only be used in /verify-2fa or /me/totp-secret endpoints (see below)."
    type: apiKey # actually apiKey is not correct type but 'bearer' type is not supported in swagger v2.0
    in: header
    name: "Authorization"
security:
  - bearer_auth: []
  - basic_auth: []
schemes:
  - http
  - https
tags:
  - name: "Login"
    description: For more details https://oss.rport.io/docs/no02-api-auth.html
  - name: "Profile & Info"
    description: "Profile and System Information"
  - name: "Clients and Tunnels"
    description: For more details https://oss.rport.io/docs/no09-managing-tunnels.html
  - name: "Client Groups"
    description: For more details https://oss.rport.io/docs/no04-client-groups.html
  - name: "Rport Client Auth Credentials"
    description: For more details https://oss.rport.io/docs/no03-client-auth.html
  - name: "Commands"
    description: For more details https://oss.rport.io/docs/no06-command-execution.html
  - name: "Users"
    description: For more details https://oss.rport.io/docs/no12-user.html
paths:
  /login:
    get:
      tags:
        - "Login"
      summary: "Generate auth token. Requires HTTP-basic authorization"
      description: "If 2FA is disabled: returns authorization JWT token.\n
      If 2FA is enabled: triggers sending 2FA token to the user. 2fa token can be further verified using `/verify-2fa` endpoint. Requires the user to have a valid `two_fa_send_to` delivery option\n
      If TotP is enabled, it returns a login token, which should be used to call `/verify-2fa` endpoint and also to create and read a totp secret for the first time (see `/me/totp-secret`)\n
      "
      parameters:
        - name: "token-lifetime"
          in: "query"
          description: "initial lifetime of JWT token in seconds. Max value is 90 days. Default: 10 min"
          required: false
          default: 600
          maximum: 7776000
          type: "integer"
      produces:
        - "application/json"
      responses:
        "200":
          description: "Successful Operation"
          schema:
            type: "object"
            properties:
              data:
                $ref: "#/definitions/LoginResponse"
        "400":
          description: "Invalid parameters"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "401":
          description: "Unauthorized"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "500":
          description: "Invalid Operation"
          schema:
            $ref: "#/definitions/ErrorPayload"
    post:
      tags:
        - "Login"
      summary: "Generate auth token. Requires username and password in request body"
      description: "If 2FA is disabled: returns authorization JWT token.\n
      If 2FA is enabled: triggers sending 2FA token to the user. 2fa token can be further verified using `/verify-2fa` endpoint. Requires the user to have a valid `two_fa_send_to` delivery option.\n
      `username` and `password` should be provided in request body either in JSON either in x-www-formurlencoded format.\n
      If time based one time passwords (TotP) are enabled (Google/Microsoft authenticator app), it returns a login token, which should be used to call `/verify-2fa` endpoint and also to create and totp secret key for the first time (see `/me/totp-secret`)\n
      To understand if TotP is enabled, `delivery_method` field will contain `totp_authenticator_app` value, that indicates the limited scope of the JWT token validity.\n
      If user has already a TotP secret key, the value of totp_key_status field will be 'pending' or 'exists' otherwise.
      "
      # swagger 2.0 does not allow describing a method that accepts multiple content-types
      parameters:
        - name: "token-lifetime"
          in: "query"
          description: "initial lifetime of JWT token in seconds. Max value is 90 days. Default: 10 min"
          required: false
          default: 600
          maximum: 7776000
          type: "integer"
      produces:
        - "application/json"
      responses:
        "200":
          description: "Successful Operation"
          schema:
            type: "object"
            properties:
              data:
                $ref: "#/definitions/LoginResponse"
        "400":
          description: "Invalid parameters"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "401":
          description: "Unauthorized"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "500":
          description: "Invalid Operation"
          schema:
            $ref: "#/definitions/ErrorPayload"
  /logout:
    delete:
      tags:
        - "Login"
      summary: "Revoke token. Requires Bearer authorization provided"
      description: ""
      produces:
        - "application/json"
      responses:
        "204":
          description: "Token revoked"
        "400":
          description: "Invalid parameters"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "500":
          description: "Invalid Operation"
          schema:
            $ref: "#/definitions/ErrorPayload"
  /verify-2fa:
    post:
      tags:
        - "Login"
      summary: "Verify 2FA token of the user. Requires enabled 2FA or time based one time code generation (totp_enabled=true)."
      description: "Returns authorization JWT token if athe provided username and his 2fa token are valid. If totp_enabled is true, you should provide one time password as 2fa token.\n
      If both 2FA and TotP are disabled, this api will return 400."
      produces:
        - "application/json"
      parameters:
        - name: "token-lifetime"
          in: "query"
          description: "initial lifetime of JWT token in seconds. Max value is 90 days. Default: 10 min"
          required: false
          default: 600
          maximum: 7776000
          type: "integer"
        - in: "body"
          name: "body"
          description: "Username and his 2FA token"
          required: true
          schema:
            type: "object"
            properties:
              username:
                type: "string"
                description: "Unique username"
              token:
                type: "string"
                description: "2FA or TotP options should be enabled. Requires JWT bearer token received from `/login` endpoint. 2FA token that was sent to the user by `/login` endpoints or generated by an Authenticator application. If totp_enabled is true, provide here one time password generated by an Authenticator app."
      responses:
        "200":
          description: "Successful Operation"
          schema:
            type: "object"
            properties:
              data:
                type: "object"
                properties:
                  token:
                    type: "string"
                    description: "Authorization JWT token"
        "400":
          description: "Invalid Request"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "401":
          description: "Unauthorized, if invalid login token is provided"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "409":
          description: "2FA is disabled. If totp_enabled is true, this error will indicate that the user hasn't generated a TotP private key yet (see /me/totp-secret)"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "500":
          description: "Invalid Operation"
          schema:
            $ref: "#/definitions/ErrorPayload"
  /me:
    get:
      tags:
        - "Profile & Info"
      summary: "Return currently logged in user and groups the user belongs to"
      description: ""
      produces:
        - "application/json"
      responses:
        "200":
          description: "Successful Operation"
          schema:
            type: "object"
            properties:
              data:
                $ref: "#/definitions/UserGet"
        "404":
          description: "User not found"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "500":
          description: "Invalid Operation"
          schema:
            $ref: "#/definitions/ErrorPayload"
    put:
      tags:
        - "Profile & Info"
      summary: "Update your own username, password or two_fa_send_to"
      produces:
        - "application/json"
      parameters:
        - in: "body"
          name: "updated params"
          description: "your own parameters that you would like to update"
          required: true
          schema:
            type: "object"
            properties:
              username:
                type: "string"
                description: "new username, empty if keep the same"
              password:
                type: "string"
                description: "new password, empty if keep the same"
              old_password:
                type: "string"
                description: "old password, required only on password change"
              two_fa_send_to:
                type: "string"
                description: "applicable only when 2FA is enabled, ignored otherwise. New two_fa_send_to, empty if keep the same"
      responses:
        "204":
          description: "Successful Operation"
        "400":
          description: "Invalid request parameters"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "401":
          description: "Unauthorized"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "403":
          description: "Missing or incorrect old password"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "500":
          description: "Invalid Operation"
          schema:
            $ref: "#/definitions/ErrorPayload"
  /me/ip:
    get:
      tags:
        - "Profile & Info"
      summary: "Return a public ip address of a client who makes the request"
      description: ""
      produces:
        - "application/json"
      responses:
        "200":
          description: "Client's ip address"
          schema:
            type: "object"
            properties:
              data:
                type: "object"
                properties:
                  ip:
                    type: "string"
  /me/token:
    post:
      tags:
        - "Profile & Info"
      summary: "Generate a new API token for user and return it"
      produces:
        - "application/json"
      responses:
        "200":
          description: "API token"
          schema:
            type: "object"
            properties:
              data:
                type: "object"
                properties:
                  token:
                    type: "string"
                    format: "uuid"
        "401":
          description: "Unauthorized"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "500":
          description: "Invalid Operation"
          schema:
            $ref: "#/definitions/ErrorPayload"
    delete:
      tags:
        - "Profile & Info"
      summary: "Delete user's API token"

      responses:
        "204":
          description: "Successful operation."
        "401":
          description: "Unauthorized"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "500":
          description: "Invalid Operation"
          schema:
            $ref: "#/definitions/ErrorPayload"
  /status:
    get:
      tags:
        - "Profile & Info"
      summary: "Get information about rport server"
      description: "Show health status, server version, etc"
      produces:
        - "application/json"
      responses:
        "200":
          description: "Successful Operation"
          schema:
            type: "object"
            properties:
              data:
                type: "object"
                properties:
                  version:
                    type: "string"
                  clients_connected:
                    type: "integer"
                  clients_disconnected:
                    type: "integer"
                  clients_auth_source:
                    description: "The source of clients authentication credentials"
                    type: "string"
                    enum: ["Static Credentials", "File", "DB"]
                  clients_auth_mode:
                    description: "Shows whether it's allowed or not to create/update/delete clients authentication credentials"
                    type: "string"
                    enum: ["Read Only", "Read Write"]
                  fingerprint:
                    type: "string"
                  connect_url:
                    description: "Full client connect URL(s)"
                    type: "array"
                    items:
                      type: "string"
                  users_auth_source:
                    description: "The source of API users authentication credentials"
                    type: "string"
                    enum: ["Static Credentials", "File", "DB"]
                  two_fa_enabled:
                    description: "True if two-factor authentication or totp auth is enabled"
                    type: "boolean"
                  two_fa_delivery_method:
                    description: "Delivery method that is used to send auth tokens when 2FA is enabled, if totp is enabled, 'totp_authenticator_app' is returned"
                    type: "string"
                    enum: ["email", "pushover", "totp_authenticator_app"]
                  tunnel_proxy_enabled:
                    description: "True if tunnel reverse proxy is enabled"
                    type: "boolean"
                  used_ports:
                    type: "array"
                    description: "Shows a list of port numbers or ranges of server ports, that are used for automatic and manual port assignment"
                    items:
                      type: "string"
                  excluded_ports:
                    type: "array"
                    description: "Shows a list of port numbers or ranges of server ports, that are not used for automatic and manual port assignment"
                    items:
                      type: "string"
              meta:
                type: "object"
        "500":
          description: "Invalid Operation"
          schema:
            $ref: "#/definitions/ErrorPayload"
  /clients:
    get:
      tags:
        - "Clients and Tunnels"
      parameters:
        - name: "sort"
          in: "query"
          description: "Sort option `-<field>`(desc) or `<field>`(asc). `<field>` can be one of `'id', 'name', 'os', 'hostname', 'version'`. For example, `&sort=-name` or `&sort=hostname`, etc"
          required: false
          type: "string"
        - name: "filter"
          in: "query"
          description: "Filter option `filter[<FIELD>]=<VALUE>` or `filter[<FIELD>|<FIELD>]=<VALUE>,<VALUE>` for OR conditions.\n
          `<FIELD>` can be one of `'id', 'name', 'os', 'os_arch', 'os_family', 'os_kernel', 'os_full_name', 'os_version', 'os_virtualization_system', 'os_virtualization_role', 'cpu_family', 'cpu_model', 'cpu_model_name', 'cpu_vendor', 'num_cpus', 'timezone', 'hostname', 'ipv4', 'ipv6', 'tags', 'version', 'address' 'client_auth_id', 'allowed_user_groups' and 'groups'`. You can use `*` to filter on any field.\n
          Multiple filters are possible. You can use `*` wildcards for partial matches. Text matching is case insensitive.\n
          Examples:\n
          `filter[os_full_name]=Ubuntu 20.04`\n
          `filter[os_full_name]=Ubuntu 20.04,Ubuntu 18.04`\n
          `filter[os_full_name|os]=Ubuntu*`\n
          `filter[*]=*Ubuntu*,*10.10.*,*Redhat*`"
          required: false
          type: "string"
        - in: "query"
          name: "fields[<RESOURCE>]"
          description: "Fields to be returned. It should be provided in the format as `fields[<RESOURCE>]=<FIELDS>`,
              where `<RESOURCE>` is `clients` and `<FIELDS>` is a comma separated list of fields. Example: `fields[clients]=id,name`.
              If no fields are specified, only id, name and hostname will be returned."
          required: false
          type: "string"
        - name: "page"
          in: "query"
          required: false
          type: "integer"
          description: Pagination options `page[limit]` and `page[offset]` can be used to get more than the first page of results. Default limit is 50 and maximum is 500. The `count` property in meta shows the total number of results.
      summary: "List all active and disconnected client connections. By default sorted by ID in asc order"
      description: ""
      produces:
        - "application/json"
      responses:
        "200":
          description: "success response"
          schema:
            type: "object"
            properties:
              data:
                type: "array"
                items:
                  $ref: "#/definitions/Client"
              meta:
                type: "object"
                properties:
                  count:
                    type: "integer"
        "400":
          description: "invalid request parameters"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "500":
          description: "invalid operation"
          schema:
            $ref: "#/definitions/ErrorPayload"
  /tunnels:
    get:
      tags:
        - "Clients and Tunnels"
      summary: "Returns all active tunnels of rport clients that current user has access to"
      description: ""
      produces:
        - "application/json"
      responses:
        "200":
          description: "success response"
          schema:
            type: "object"
            properties:
              data:
                type: "array"
                items:
                  $ref: "#/definitions/Tunnel"
        "500":
          description: "invalid operation"
          schema:
            $ref: "#/definitions/ErrorPayload"
  /clients/{client_id}:
    get:
      tags:
        - "Clients and Tunnels"
      summary: "Get client by id"
      parameters:
        - name: "client_id"
          in: "path"
          description: "unique client ID"
          required: true
          type: "string"
        - in: "query"
          name: "fields[<RESOURCE>]"
          description: "Fields to be returned. It should be provided in the format as `fields[<RESOURCE>]=<FIELDS>`,
              where `<RESOURCE>` is `clients` and `<FIELDS>` is a comma separated list of fields. Example: `fields[clients]=id,name`.
              If no fields are specified, all will be returned."
          required: false
          type: "string"
      produces:
        - "application/json"
      responses:
        "200":
          description: "success response"
          schema:
            type: "object"
            properties:
              data:
                $ref: "#/definitions/Client"
        "404":
          description: "Client not found"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "500":
          description: "Invalid operation"
          schema:
            $ref: "#/definitions/ErrorPayload"
    delete:
      tags:
        - "Clients and Tunnels"
      summary:  "Delete a disconnected client by id"
      description: "Deletes a client by a given id. This API requires the current client to be offline. Returns 400 otherwise."
      produces:
        - "application/json"
      parameters:
        - name: "client_id"
          in: "path"
          description: "unique client ID"
          required: true
          type: "string"
      responses:
        "204":
          description: "Successful operation."
        "400":
          description: "Invalid request: client is active or provided client ID is empty."
          schema:
            $ref: "#/definitions/ErrorPayload"
        "404":
          description: "Client not found"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "500":
          description: "Invalid operation"
          schema:
            $ref: "#/definitions/ErrorPayload"
  /clients/{client_id}/tunnels:
    parameters:
      - name: "client_id"
        in: "path"
        description: "unique client id retrieved previously"
        required: true
        type: "string"
      - name: "local"
        in: "query"
        description: "local refers to the local port of the rport server to use for a new tunnel, e.g. '3390' or '0.0.0.0:3390'. If local is not specified, a random free server port will be selected automatically"
        required: false
        type: "string"
      - name: "remote"
        in: "query"
        description: "remote address endpoint, e.g. '3389', '0.0.0.0:22' or '192.168.178.1:80', etc"
        required: true
        type: "string"
      - name: "scheme"
        in: "query"
        description: "URI scheme to be used. For example, 'ssh', 'rdp', etc."
        required: false
        type: "string"
      - name: "acl"
        in: "query"
        description: "ACL, IP v4 addresses or ranges who is allowed to use the tunnel (ipv6 is not supported yet). For example, '142.78.90.8,201.98.123.0/24'"
        required: false
        type: "string"
      - name: "check_port"
        in: "query"
        description: "A flag whether to check availability of a public port (remote). By default check is enabled. To disable it specify 'check_port=0'."
        required: false
        type: "string"
      - name: "idle-timeout-minutes"
        in: "query"
        description: "Auto-close the tunnel after given period of inactivity in minutes. If not provided, default value is 5 minutes. This parameter should not be used with a non empty `skip-idle-timeout` parameter"
        required: false
        type: "integer"
        maximum: 10080
        minimum: 0
        default: 5
      - name: "auto-close"
        in: "query"
        description: "if > 0 then auto-close the tunnel after given duration. Valid time units are 's'(seconds), 'm'(minutes), 'h'(hours). For example, '20m', '1m30s', '1h', etc"
        required: false
        type: "string"
      - name: "protocol"
        in: "query"
        description: "Protocol for the tunnel. Can be `tcp` or `udp`. Default is `tcp`."
        required: false
        type: "string"
      - name: "skip-idle-timeout"
        in: "query"
        description: "Disables the auto-close time of the tunnel (see `idle-timeout-minutes` parameter). The parameter should not be used with a non empty `idle-timeout-minutes` parameter"
        required: false
        type: "integer"
      - name: "http_proxy"
        in: "query"
        description: "If true, triggers the start of a reverse proxy in front of the tunnel to handle ssl offloading. Default is false. `http_proxy=true` is only allowed in combination with scheme 'http' or 'https'"
        required: false
        type: "boolean"
      - name: "host_header"
        in: "query"
        description: "If http_proxy is true, you can specify a host name which will be added as header field `Host` to each outgouing proxy request. (virtual hosting on remote side)"
        required: false
        type: "string"
    put:
      tags:
        - "Clients and Tunnels"
      summary: "Request a new tunnel for an active client connection"
      description: ""
      produces:
        - "application/json"
      responses:
        "200":
          description: "success response"
          schema:
            type: "object"
            properties:
              data:
                type: "object"
                $ref: "#/definitions/Tunnel"
        "400":
          description: "invalid parameters. Error codes: ERR_CODE_LOCAL_PORT_IN_USE, ERR_CODE_REMOTE_PORT_NOT_OPEN, ERR_CODE_INVALID_ACL, ERR_CODE_TUNNEL_EXIST, ERR_CODE_TUNNEL_TO_PORT_EXIST, ERR_CODE_URI_SCHEME_LENGTH_EXCEED, ERR_CODE_INVALID_IDLE_TIMEOUT."
          schema:
            $ref: "#/definitions/ErrorPayload"
        "404":
          description: "specified client does not exist, already terminated ot disconnected"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "409":
          description: "can't create requested tunnel. Probably port already busy"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "500":
          description: "invalid operation"
          schema:
            $ref: "#/definitions/ErrorPayload"
  /clients/{client_id}/tunnels/{tunnel_id}:
    parameters:
      - name: "client_id"
        in: "path"
        description: "unique client id retrieved previously"
        required: true
        type: "string"
      - name: "tunnel_id"
        in: "path"
        description: "unique tunnel id retrieved previously"
        required: true
        type: "string"
      - name: "force"
        in: "query"
        description: "If true, terminate a tunnel even when it is still active."
        required: false
        type: "boolean"
    delete:
      tags:
        - "Clients and Tunnels"
      summary:  "Terminate a specified tunnel"
      description: ""
      responses:
        "204":
          description: "tunnel terminated"
        "400":
          description: "invalid parameters"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "404":
          description: "specified client or tunnel does not exist or already terminated"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "409":
          description: "specified tunnel is still active: it has active connections"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "500":
          description: "invalid operation"
          schema:
            $ref: "#/definitions/ErrorPayload"
  /clients/{client_id}/acl:
    post:
      tags:
        - "Clients and Tunnels"
      summary: "Limit access to a current client to user groups. Require admin access"
      description: ""
      produces:
        - "application/json"
      parameters:
        - name: "client_id"
          in: "path"
          description: "unique client id retrieved previously"
          required: true
          type: "string"
        - in: "body"
          name: "body"
          required: true
          schema:
            type: "object"
            properties:
              allowed_user_groups:
                type: "array"
                description: "list of user groups that are allowed to access this client. Empty means only Administrators can access it. You must always specify the entire list of allowed groups, partial updates are not supported"
                items:
                  type: "string"
      responses:
        "204":
          description: "Successful Operation"
        "400":
          description: "Invalid request parameters"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "404":
          description: "Client or specified user groups not found"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "500":
          description: "Invalid Operation"
          schema:
            $ref: "#/definitions/ErrorPayload"
  /clients/{client_id}/updates-status:
    post:
      tags:
        - "Clients and Tunnels"
      summary: "Trigger updates status refresh on the client"
      produces:
        - "application/json"
      parameters:
        - name: "client_id"
          in: "path"
          description: "unique client id retrieved previously"
          required: true
          type: "string"
      responses:
        "204":
          description: "Successful Operation"
        "400":
          description: "Invalid request parameters"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "404":
          description: "Client or specified user groups not found"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "500":
          description: "Invalid Operation"
          schema:
            $ref: "#/definitions/ErrorPayload"
  /clients/{client_id}/commands:
    get:
      tags:
        - "Commands"
      summary: "Return a short info about all client commands"
      description: "Return a list of all running and finished commands sorted by finished time in desc order with running commands at the beginning"
      produces:
        - "application/json"
      parameters:
        - name: "client_id"
          in: "path"
          description: "unique client id retrieved previously"
          required: true
          type: "string"
        - in: "query"
          name: "sort"
          description: "Sort field to be used for sorting, the default sorting is by finished time in desc order.\n
            To change the direction add `-` to the sorting value e.g. `-started_at`. Allowed values are `jid`, `started_at`, `finished_at`, `status`, `multi_job_id`, `created_by`, `schedule_id`.\n
            You can use as many sort parameters as you want."
          required: false
          type: "string"
        - in: "query"
          name: "filter[<FIELD>]"
          description: "Filter option `filter[<field>]` or `filter[started_at][<op>]`.
            `<field>` can be one of `jid`, `created_by`, `started_at`, `finished_at`, `status`, `multi_job_id`, `schedule_id`  and `<value>` is the search value,\n
              e.g. `filter[created_by]=admin` will request only commands created by admin. You can use as many filter parameters as you want.\n
              For `started_at` and `finished_at` filters you need to specify operation: `gt`, `lt`, `since` or `until`.\n
              If you want to filter by multiple values e.g. find entries either for created_by = admin or other you can use following filters\n
              `filter[created_by]=admin,other`."
          required: false
          type: "string"
        - name: "page"
          in: "query"
          required: false
          type: "integer"
          description: Pagination options `page[limit]` and `page[offset]` can be used to get more than the first page of results. Default limit is 100 and maximum is 1000. The `count` property in meta shows the total number of results.
      responses:
        "200":
          description: "Successful Operation"
          schema:
            type: "object"
            properties:
              data:
                type: "array"
                items:
                  $ref: "#/definitions/JobSummary"
              meta:
                type: "object"
                properties:
                  count:
                    type: "integer"
        "500":
          description: "Invalid Operation"
          schema:
            $ref: "#/definitions/ErrorPayload"
    post:
      tags:
        - "Commands"
      summary: "Execute a command by the rport client"
      description: "NOTE: if command limitation is enabled by an rport client then a full path command can be required to use. See https://oss.rport.io/docs/no06-command-execution.html for more details"
      produces:
        - "application/json"
      parameters:
        - name: "client_id"
          in: "path"
          description: "unique client id retrieved previously"
          required: true
          type: "string"
        - in: "body"
          name: "body"
          description: "remote command to execute by the rport client"
          required: true
          schema:
            type: "object"
            properties:
              command:
                type: "string"
                description: "remote command to execute by the rport client. NOTE: if command limitation is enabled by an rport client then a full path command can be required to use. See https://oss.rport.io/docs/no06-command-execution.html for more details"
              interpreter:
                type: "string"
                enum: [cmd, powershell, tacoscript]
                description: "command interpreter to use to execute the command. If not set 'cmd' is used by default on Windows and /bin/sh on Linux"
              cwd:
                type: "string"
                description: "current working directory for the executable command"
              is_sudo:
                type: "boolean"
                description: "execute a command as sudo user"
              timeout_sec:
                type: "integer"
                description: "timeout in seconds to observe the command execution. If not set a default timeout (60 seconds) is used"
                default: 60
      responses:
        "200":
          description: "Successful Operation"
          schema:
            type: "object"
            properties:
              data:
                type: "object"
                properties:
                  jid:
                    type: "string"
                    description: "job id of the corresponding command"
        "400":
          description: "Invalid request parameters"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "404":
          description: "Active client not found"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "409":
          description: "Could not execute the command. Probably a previous command is still running"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "500":
          description: "Invalid Operation"
          schema:
            $ref: "#/definitions/ErrorPayload"
  /clients/{client_id}/scripts:
    post:
      tags:
        - "Scripts"
      summary: "Execute a script by a rport client."
      description: "Rport server will copy script contents to a temp folder on an rport client. Then it will implicitly execute shell script as a command e.g. sh /tmp/script.sh.\n
       NOTE: if command limitation is enabled by an rport client then it should allow execution commands like sh script.sh or cmd script.bat or powershell -executionpolicy bypass -file script.ps1.\n
       See https://oss.rport.io/docs/no06-command-execution.html#securing-your-environment for more details"
      consumes:
        - application/json
      parameters:
        - name: "client_id"
          in: "path"
          description: "unique client id retrieved previously"
          required: true
          type: "string"
        - in: "body"
          name: "body"
          description: "script to execute by the rport client, the format depends on the client's OS"
          required: true
          schema:
            type: "object"
            properties:
              script:
                type: "string"
                description: "base64 encoded script which should be executed on a remote client"
              interpreter:
                type: "string"
                enum: [ cmd, powershell, tacoscript ]
                description: "command interpreter to use to execute the script. If not set 'cmd' is used by default on Windows and /bin/sh on Linux.\n
                For tacoscript interpreter you should install tacoscript binary from here: https://github.com/cloudradar-monitoring/tacoscript#installation. It should also be available in the system path.\n
                Additionally, you can use interpreter aliases or full absolute paths to an interpreter of your choice (see https://oss.rport.io/docs/no14-scripts.html#scripts-execution for details)."
              cwd:
                type: "string"
                description: "current working directory for the executable script"
              is_sudo:
                type: "boolean"
                description: "execute a command as sudo user, applicable only for Linux systems"
              timeout_sec:
                type: "integer"
                description: "timeout in seconds to observe the script execution. If not set a default timeout (60 seconds) is used"
                default: 60
      responses:
        "200":
          description: "Successful Operation"
          schema:
            type: "object"
            properties:
              data:
                type: "object"
                properties:
                  jid:
                    type: "string"
                    description: "job id of the underlying command which will execute the provided script"
        "400":
          description: "Invalid request parameters"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "404":
          description: "Active client not found"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "409":
          description: "Could not execute the command. Probably a previous command is still running"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "500":
          description: "Invalid Operation"
          schema:
            $ref: "#/definitions/ErrorPayload"
  /scripts:
    post:
      tags:
        - "Scripts"
      summary: "Execute a script on multiple rport clients"
      description: "This API executes the provided script on multiple clients similar to the command execution"
      produces:
        - "application/json"
      parameters:
        - in: "body"
          name: "body"
          description: "properties and remote command to execute by rport clients"
          required: true
          schema:
            type: "object"
            properties:
              data:
                $ref: "#/definitions/ExecuteScriptRequest"
      responses:
        "200":
          description: "Successful Operation"
          schema:
            type: "object"
            properties:
              data:
                type: "object"
                properties:
                  jid:
                    type: "string"
                    description: "multi job id of the corresponding command"
        "400":
          description: "Invalid request parameters"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "404":
          description: "Client not found"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "500":
          description: "Invalid Operation"
          schema:
            $ref: "#/definitions/ErrorPayload"
  /clients/{client_id}/commands/{job_id}:
    get:
      tags:
        - "Commands"
      summary: "Return a detailed info about a specific client command"
      description: "Return a detailed info about a command by given job id"
      produces:
        - "application/json"
      parameters:
        - name: "client_id"
          in: "path"
          description: "unique client id retrieved previously"
          required: true
          type: "string"
        - name: "job_id"
          in: "path"
          description: "unique job id retrieved previously"
          required: true
          type: "string"
      responses:
        "200":
          description: "Successful Operation"
          schema:
            type: "object"
            properties:
              data:
                $ref: "#/definitions/Job"
        "404":
          description: "Command not found with given client id and job id"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "500":
          description: "Invalid Operation"
          schema:
            $ref: "#/definitions/ErrorPayload"
  /commands:
    get:
      tags:
        - "Commands"
      summary: "Return a short info about all multi-client commands"
      description: "Return a list of all running and finished commands sorted by started time in desc order"
      produces:
        - "application/json"
      parameters:
        - in: "query"
          name: "sort"
          description: "Sort field to be used for sorting, the default sorting is by started time in desc order.\n
            To change the direction add `-` to the sorting value e.g. `-started_at`. Allowed values are `jid`, `started_at`, `created_by`, `schedule_id`.\n
            You can use as many sort parameters as you want."
          required: false
          type: "string"
        - in: "query"
          name: "filter[<FIELD>]"
          description: "Filter option `filter[<field>]` or `filter[started_at][<op>]`.
            `<field>` can be one of `jid`, `created_by`, `started_at`, `schedule_id`  and `<value>` is the search value,\n
              e.g. `filter[created_by]=admin` will request only commands created by admin. You can use as many filter parameters as you want.\n
              For `started_at` filter you need to specify operation: `gt`, `lt`, `since` or `until`.\n
              If you want to filter by multiple values e.g. find entries either for created_by = admin or other you can use following filters\n
              `filter[created_by]=admin,other`."
          required: false
          type: "string"
        - name: "page"
          in: "query"
          required: false
          type: "integer"
          description: Pagination options `page[limit]` and `page[offset]` can be used to get more than the first page of results. Default limit is 100 and maximum is 1000. The `count` property in meta shows the total number of results.
      responses:
        "200":
          description: "Successful Operation"
          schema:
            type: "object"
            properties:
              data:
                type: "array"
                items:
                  $ref: "#/definitions/MultiJobSummary"
              meta:
                type: "object"
                properties:
                  count:
                    type: "integer"
        "500":
          description: "Invalid Operation"
          schema:
            $ref: "#/definitions/ErrorPayload"
    post:
      tags:
        - "Commands"
      summary: "Execute a command on multiple rport clients"
      description: "NOTE: if command limitation is enabled by an rport client then a full path command can be required to use. See https://oss.rport.io/docs/no06-command-execution.html for more details"
      produces:
        - "application/json"
      parameters:
        - in: "body"
          name: "body"
          description: "properties and remote command to execute by rport clients"
          required: true
          schema:
            type: "object"
            properties:
              command:
                type: "string"
                description: "remote command to execute by rport clients. NOTE: if command limitation is enabled by an rport client then a full path command can be required to use. See https://oss.rport.io/docs/no06-command-execution.html for more details"
              client_ids:
                type: "array"
                items:
                  type: string
                description: "list of client IDs where to run the command. Min items is 2 if group_ids is not specified"
              group_ids:
                type: "array"
                items:
                  type: string
                description: "list of client group IDs. A command will be executed on all clients that belong to given group(s)"
              interpreter:
                type: "string"
                enum: [cmd, powershell]
                description: "command interpreter to use to execute the command. Is applicable only for windows clients. If not set 'cmd' is used by default"
              timeout_sec:
                type: "integer"
                description: "timeout in seconds to observe the command execution on each client separately. If not set a default timeout (60 seconds) is used"
                default: 60
              execute_concurrently:
                type: "boolean"
                description: "if true - execute the command concurrently on clients. If false - sequentially in order that is in 'client_ids'. By default is false"
                default: false
              abort_on_error:
                type: "boolean"
                description: "applicable only if 'execute_concurrently' is false. If true - abort the entire cycle if the execution fails on some client. By default is true"
                default: true
              cwd:
                type: "string"
                description: "current working directory for an executable command"
              is_sudo:
                type: "boolean"
                description: "execute the command as a sudo user"
      responses:
        "200":
          description: "Successful Operation"
          schema:
            type: "object"
            properties:
              data:
                type: "object"
                properties:
                  jid:
                    type: "string"
                    description: "multi job id of the corresponding command"
        "400":
          description: "Invalid request parameters"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "404":
          description: "Client not found"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "500":
          description: "Invalid Operation"
          schema:
            $ref: "#/definitions/ErrorPayload"
  /commands/{job_id}:
    get:
      tags:
        - "Commands"
      summary: "Return a detailed info about a specific multi-client command"
      description: "Return a detailed info about a multi-client command by given id with child jobs as well"
      produces:
        - "application/json"
      parameters:
        - name: "job_id"
          in: "path"
          description: "unique multi job id retrieved previously"
          required: true
          type: "string"
      responses:
        "200":
          description: "Successful Operation"
          schema:
            type: "object"
            properties:
              data:
                $ref: "#/definitions/MultiJob"
        "400":
          description: "Command not found with a given multi job id"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "500":
          description: "Invalid Operation"
          schema:
            $ref: "#/definitions/ErrorPayload"
  /ws/commands:
    get:
      tags:
        - "Commands"
      summary: "Web Socket Connection to execute a remote command on rport client(s)"
      description: "
      NOTE: swagger is not designed to document WebSocket API. This is a temporary solution.\n

      A new web socket is created for each new request to execute a remote command on rport client(s).\n
      Steps:\n
      1. To pass authentication - include \"access_token\" param into the url. The value is a jwt token that is created by 'login' API endpoint.\n
      2. Upgrades the current connection to Web Socket.\n
      3. Then server waits for an inbound message from UI client. It should be a JSON object `ExecuteCmdRequest`(see in 'Models')\n
      For example,\n
      {\n
        \"command\": \"/usr/bin/whoami\",\n
        \"client_ids\": [ \"qa-lin-debian9\", \"qa-lin-debian10\", \"qa-lin-centos8\", \"qa-lin-ubuntu18\", \"qa-lin-ubuntu16\" ],\n
        \"group_ids\": [ \"group-1\"],\n
        \"timeout_sec\": 30,\n
        \"cwd\": \"/users/root\",\n
        \"execute_concurrently\": true\n,
        \"is_sudo\": true\n,
      }\n
      4. Validates the inbound msg. If it fails - server sends an outbound JSON message `ErrorPayload`(see in 'Models') and closes the connection.\n
      5. Server sends a given command to rport client(s) to execute.\n
      6. As soon as it gets a result from each rport client - it sends an outbound JSON message `Job`(see in 'Models').\n
         It can contain a non-empty 'error' field if server wasn't able to send the command to the rport client.\n
         Number of outbound messages is expected to be as many as rport clients. Or less if it's not a concurrent mode and 'abort_on_error' is turned on.\n
      7. As soon as all rport clients send back the result - connection is closed by server.\n
      8. Also, a current connection can be closed by UI client.\n

      There is a simple UI for testing. Try it out http://127.0.0.1:3000/api/v1/test/commands/ui\n
      "
      produces:
        - "application/json"
      parameters:
        - name: "access_token"
          in: "query"
          description: "JWT token that is created by 'login' API endpoint. Required to pass the authentication."
          required: true
          type: "string"
      responses:
        "200":
          description: "On success upgrades current connection to websocket"
          schema:
            type: "object"
  /ws/scripts:
    get:
      tags:
        - "Scripts"
      summary: "Web Socket Connection to execute scripts on rport client(s)"
      description: "
      NOTE: swagger is not designed to document WebSocket API. This is a temporary solution.\n

      A new web socket is created for each new request to execute a script on rport client(s).\n
      Steps:\n
      1. To pass authentication - include \"access_token\" param into the url. The value is a jwt token that is created by 'login' API endpoint.\n
      2. Upgrades the current connection to Web Socket.\n
      3. Then server waits for an inbound script message from UI client. It should be a JSON object `ExecuteScriptRequest`(see in 'Models'):\n
      For example,\n
        {\n
          \"script\": \"Y2QgL1VzZXJzL2JyZWF0aGJhdGgvc3NsCmxzIC1sYQpjZCBnb2tleQpjYXQgTElDRU5TRQ==\",\n
          \"client_ids\": [ \"qa-lin-debian9\", \"qa-lin-debian10\", \"qa-lin-centos8\", \"qa-lin-ubuntu18\", \"qa-lin-ubuntu16\" ],\n
          \"group_ids\": [ \"group-1\"],\n
          \"timeout_sec\": 30,\n
          \"cwd\": \"/users/root\",\n
          \"execute_concurrently\": true\n,
          \"is_sudo\": true\n,
        }\n
      5. Rport server will create the provided script as a shell script file in the target client(s) (e.g. `/tmp/f68a779d-1d46-414a-b165-d8d2df5f348c.sh` or `f68a779d-1d46-414a-b165-d8d2df5f348.ps1`).\n
      Then it will run this script as a regular command e.g. `sh /tmp/f68a779d-1d46-414a-b165-d8d2df5f348c.sh`\n
      If it fails, the server sends an outbound JSON message `ErrorPayload`(see in 'Models') and closes the connection. The temp script will be deleted anyway.\n
      6. As soon as Rport server gets a result from client(s) - it sends an outbound JSON message `Job`(see in 'Models').\n
         It can contain a non-empty 'error' field if server wasn't able to send the command to the rport client.\n
      7. As soon as a rport client sends back the result - connection is closed by server.\n
      8. Also, a current connection can be closed by UI client.\n
      There is a simple UI for testing. Try it out http://127.0.0.1:3000/api/v1/test/scripts/ui. You can enable this api by setting `enable_ws_test_endpoints=true` in the configuration file \n"
      produces:
        - "application/json"
      parameters:
        - name: "access_token"
          in: "query"
          description: "JWT token that is created by 'login' API endpoint. Required to pass the authentication."
          required: true
          type: "string"
      responses:
        "200":
          description: "On success upgrades current connection to websocket"
          schema:
            type: "object"
  /ws/uploads:
    get:
      tags:
        - "Upload"
      summary: "Web Socket Connection to track upload process on clients"
      description: "
      NOTE: swagger is not designed to document WebSocket API. This is a temporary solution.\n

      The web socket API tracks uploads for all clients and all requests.\n
      Steps:\n
      1. To pass authentication - include \"access_token\" param into the url. The value is a jwt token that is created by 'login' API endpoint.\n
      2. Upgrades the current connection to Web Socket.\n
      3. Once the conneciton is open, all uploads to the clients can be tracked through it
      4. Server receives an upload request, stores a file in a temp location and sends this information to all provided clients.
      5. Clients will establish an sftp connection on top of the existing ssh connection and will download file from the servers temp folder and store it in its own temp folder
      6. After download success, client will move the uploaded file from the temp to the desired path and perform chmod/chown operations if needed
      7. The result (success/failure/partial failure/ignore) will be reported to the server through the SSH connection
      8. The Rport server will send the client upload results to all open websocket connections
      9. The websocket connection will stay open till client closes it
      There is a simple UI for testing. Try it out http://127.0.0.1:3000/api/v1/test/uploads/ui. You can enable this api by setting `enable_ws_test_endpoints=true` in the configuration file \n"
      produces:
        - "application/json"
      parameters:
        - name: "access_token"
          in: "query"
          description: "JWT token that is created by 'login' API endpoint. Required to pass the authentication."
          required: true
          type: "string"
      responses:
        "200":
          description: "On success upgrades current connection to websocket"
          schema:
            type: "object"
            properties:
              data:
                $ref: "#/definitions/ClientUploadResponse"
  /clients-auth:
    get:
      tags:
        - "Rport Client Auth Credentials"
      summary: "Return all rport clients authentication credentials. Sorted by ID in asc order. Require admin access"
      description: ""
      produces:
        - "application/json"
      responses:
        "200":
          description: "Successful Operation"
          schema:
            type: "object"
            properties:
              data:
                type: "array"
                items:
                  $ref: "#/definitions/ClientAuth"
        "500":
          description: "Invalid Operation"
          schema:
            $ref: "#/definitions/ErrorPayload"
    post:
      tags:
        - "Rport Client Auth Credentials"
      summary: "Add new rport client authentication credentials. Require admin access"
      description: ""
      produces:
        - "application/json"
      parameters:
        - in: "body"
          name: "body"
          description: "Client auth credentials to add"
          required: true
          schema:
            $ref: "#/definitions/ClientAuth"
      responses:
        "204":
          description: "New client auth credentials added"
        "400":
          description: "Invalid parameters"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "409":
          description: "Client auth credentials already exist. Err code: ERR_CODE_ALREADY_EXIST"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "500":
          description: "Invalid Operation"
          schema:
            $ref: "#/definitions/ErrorPayload"
  /clients-auth/{client_auth_id}:
    parameters:
      - name: "client_auth_id"
        in: "path"
        description: "client auth ID"
        required: true
        type: "string"
      - name: "force"
        in: "query"
        description: "If true, delete a client auth even when it has active/disconnected clients."
        required: false
        type: "boolean"
    delete:
      tags:
        - "Rport Client Auth Credentials"
      summary:  "Delete rport client authentication credentials. Require admin access"
      description: ""
      responses:
        "204":
          description: "Client auth credentials deleted."
        "400":
          description: "Invalid parameters"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "404":
          description: "Client auth credentials not found"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "405":
          description: "Operation not allowed. Error codes: ERR_CODE_CLIENT_AUTH_SINGLE, ERR_CODE_CLIENT_AUTH_RO"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "409":
          description: "Could not delete. Client Auth has active or disconnected bound client(s). Err code: ERR_CODE_CLIENT_AUTH_HAS_CLIENT"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "500":
          description: "Invalid Operation"
          schema:
            $ref: "#/definitions/ErrorPayload"
  /client-groups:
    get:
      tags:
        - "Client Groups"
      summary: "Return all client groups"
      description: "Return a list of all existing client groups sorted by ID in asc order"
      produces:
        - "application/json"
      responses:
        "200":
          description: "Successful Operation"
          schema:
            type: "object"
            properties:
              data:
                type: "array"
                items:
                  $ref: "#/definitions/ClientGroup"
        "500":
          description: "Invalid Operation"
          schema:
            $ref: "#/definitions/ErrorPayload"
    post:
      tags:
        - "Client Groups"
      summary: "Create a new client group. Require admin access"
      description: "Create a new client group."
      produces:
        - "application/json"
      parameters:
        - in: "body"
          name: "client group"
          description: "Client group to create. Note: ClientGroup.client_ids field should not be set. It's read-only"
          required: true
          schema:
            $ref: '#/definitions/ClientGroup'
      responses:
        "201":
          description: "Successful Operation"
        "400":
          description: "Invalid request parameters"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "500":
          description: "Invalid Operation"
          schema:
            $ref: "#/definitions/ErrorPayload"
  /client-groups/{group_id}:
    get:
      tags:
        - "Client Groups"
      summary: "Return a client group"
      description: "Return a detailed info about a client group by a given id"
      produces:
        - "application/json"
      parameters:
        - name: "group_id"
          in: "path"
          description: "unique client group ID"
          required: true
          type: "string"
      responses:
        "200":
          description: "Successful Operation"
          schema:
            type: "object"
            properties:
              data:
                $ref: "#/definitions/ClientGroup"
        "404":
          description: "Client group not found"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "500":
          description: "Invalid Operation"
          schema:
            $ref: "#/definitions/ErrorPayload"
    put:
      tags:
        - "Client Groups"
      summary: "Save a client group. Require admin access"
      description: "Update an existing client group or save a new client group"
      produces:
        - "application/json"
      parameters:
        - name: "group_id"
          in: "path"
          description: "unique client group ID"
          required: true
          type: "string"
        - in: "body"
          name: "client group"
          description: "Client group to save. Note: ClientGroup.client_ids field should not be set."
          required: true
          schema:
            $ref: '#/definitions/ClientGroup'
      responses:
        "204":
          description: "Successful Operation"
        "400":
          description: "Invalid request parameters"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "500":
          description: "Invalid Operation"
          schema:
            $ref: "#/definitions/ErrorPayload"
    delete:
      tags:
        - "Client Groups"
      summary: "Delete a client group. Require admin access"
      description: "Delete a client group by a given id"
      produces:
        - "application/json"
      parameters:
        - name: "group_id"
          in: "path"
          description: "unique client group ID"
          required: true
          type: "string"
      responses:
        "204":
          description: "Successful Operation"
        "500":
          description: "Invalid Operation"
          schema:
            $ref: "#/definitions/ErrorPayload"
  /users:
    get:
      tags:
        - "Users"
      summary: "Return all users"
      description: "Return a list of all existing users sorted by username in asc order.
      This API requires the current user to be member of group `Administrators`. Returns 403 otherwise.
      The `Administrators` group name is hardcoded and cannot be changed at the moment"
      produces:
        - "application/json"
      responses:
        "200":
          description: "Successful Operation"
          schema:
            type: "object"
            properties:
              data:
                type: "array"
                items:
                  $ref: "#/definitions/UserGet"
        "400":
          description: "server runs on a static user-password pair, please use JSON file or database for user data"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "403":
          description: "current user should belong to Administrators group to access this resource"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "500":
          description: "Invalid Operation"
          schema:
            $ref: "#/definitions/ErrorPayload"
    post:
      tags:
        - "Users"
      summary: "Create a new user"
      description: "Create a new user.
      This API requires the current user to be member of group `Administrators`. Returns 403 otherwise.
      The `Administrators` group name is hardcoded and cannot be changed at the moment"
      produces:
        - "application/json"
      parameters:
        - in: "body"
          name: "user"
          description: "User to create."
          required: true
          schema:
            $ref: '#/definitions/UserPost'
      responses:
        "201":
          description: "Successful Operation"
        "400":
          description: "Invalid request parameters"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "403":
          description: "current user should belong to Administrators group to access this resource"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "500":
          description: "Invalid Operation"
          schema:
            $ref: "#/definitions/ErrorPayload"
  /users/{user_id}:
    put:
      tags:
        - "Users"
      summary: "Update a user identified by the provided id"
      description: "Update an existing user.
      This API requires the current user to be member of group `Administrators`. Returns 403 otherwise.
            The `Administrators` group name is hardcoded and cannot be changed at the moment."
      produces:
        - "application/json"
      parameters:
        - name: "user_id"
          in: "path"
          description: "unique user ID"
          required: true
          type: "string"
        - in: "body"
          name: "user"
          description: "User to update. Please note, that if you provide some key/values like `username: login1`, the not mentioned keys won't be changed, e.g. `password`"
          required: true
          schema:
            $ref: '#/definitions/UserPost'
      responses:
        "204":
          description: "Successful Operation"
        "400":
          description: "Invalid request parameters"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "403":
          description: "current user should belong to Administrators group to access this resource"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "500":
          description: "Invalid Operation"
          schema:
            $ref: "#/definitions/ErrorPayload"
    delete:
      tags:
        - "Users"
      summary: "Delete a user"
      description: "Deletes a user by a given id.
      This API requires the current user to be member of group `Administrators`. Returns 403 otherwise.
            The `Administrators` group name is hardcoded and cannot be changed at the moment"
      produces:
        - "application/json"
      parameters:
        - name: "user_id"
          in: "path"
          description: "unique user ID"
          required: true
          type: "string"
      responses:
        "204":
          description: "Successful Operation"
        "403":
          description: "current user should belong to Administrators group to access this resource"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "500":
          description: "Invalid Operation"
          schema:
            $ref: "#/definitions/ErrorPayload"
  /users/{user_id}/totp-secret:
    delete:
      tags:
        - "Users"
      summary: "Delete time based one time private key for the provided user. Requires a token received from `/verify-2fa` endpoint."
      description: "Deletes private key for an Authenticator app. This API requires the current user to be member of group `Administrators`. Returns 403 otherwise.
            The `Administrators` group name is hardcoded and cannot be changed at the moment"
      produces:
        - "application/json"
      parameters:
        - name: "user_id"
          in: "path"
          description: "unique user ID"
          required: true
          type: "string"
      responses:
        "204":
          description: "Successful Operation"
        "400":
          description: "TotP is disabled"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "403":
          description: "current user should belong to Administrators group to access this resource"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "500":
          description: "Invalid Operation"
          schema:
            $ref: "#/definitions/ErrorPayload"
  /vault-admin:
    get:
      tags:
        - "Vault"
      summary: "Get status of RPort vault"
      description: "Returns status information about the Rport vault."
      produces:
        - "application/json"
      responses:
        "200":
          description: "Successful Operation"
          schema:
            type: "object"
            properties:
              data:
                type: "object"
                properties:
                  init:
                    type: "string"
                    enum: [setup-completed, uninitialized]
                    description: "vault initialization status: if setup-completed vault is initialized or uninitialized otherwise"
                  status:
                    type: "string"
                    enum: [ locked, unlocked ]
                    description: "vault lock status"
        "401":
          description: "Unauthorized"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "500":
          description: "Invalid Operation"
          schema:
            $ref: "#/definitions/ErrorPayload"
  /vault:
    get:
      tags:
        - "Vault"
      summary: "Read or find vault entries"
      description: "Reads all vault entries or find some based on the input parameters"
      produces:
        - "application/json"
      parameters:
        - in: "query"
          name: "sort"
          description: "Sort field to be used for values, the sorting direction is by default ASC.\n
          To change the direction add `-` to the sorting value e.g. `-id`. Allowed values are `id`, `client_id`, `created_by`, `created_at`, `key`.\n
          You can use as many sort parameters as you want."
          required: false
          type: "string"
        - in: "query"
          name: "filter[<FIELD>]"
          description: "Filter to find vault entries. It should be provided in the format as `filter[<FIELD>]=<VALUE>`,\n
            where `<FIELD>` is one of the values `id`, `client_id`, `created_by`, `created_at`, `key` and `<VALUE>` is the search value,\n
            e.g. `filter[created_by]=admin` will request only vault entries created by admin. You can use as many filter parameters as you want.\n
            If you want to filter by multiple values e.g. find entries either for client_id = client1 or client2 you can use following filters\n
            `filter[client_id]=client1,client2`.
            "
          required: false
          type: "string"
      responses:
        "200":
          description: "Successful Operation"
          schema:
            type: "object"
            properties:
              data:
                type: "array"
                items:
                  $ref: "#/definitions/VaultEntryOutputShort"
        "400":
          description: "unsupported sort field 'xyz'"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "401":
          description: "Unauthorized"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "409":
          description: "vault is locked or not initialized"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "500":
          description: "Invalid Operation"
          schema:
            $ref: "#/definitions/ErrorPayload"
    post:
      tags:
        - "Vault"
      summary: "Creates a new vault entry"
      description: "Creates a new entry in vault with the encrypted value field.\n
      If another entry with the same key and client id combination exists, an error will be returned."
      produces:
        - "application/json"
      parameters:
        - in: "body"
          name: "body"
          description: "value in the json format"
          required: true
          schema:
            $ref: "#/definitions/VaultEntryInput"
      responses:
        "201":
          description: "Successful Operation"
          schema:
            type: "object"
            properties:
              data:
                type: "object"
                properties:
                  id:
                    type: "integer"
                    description: "unique internal id of the created vault entry"
        "400":
          description: "Invalid request parameters"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "401":
          description: "Unauthorized"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "409":
          description: "vault is locked or not initialized or another key exists for this client"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "500":
          description: "Invalid Operation"
          schema:
            $ref: "#/definitions/ErrorPayload"
  /vault/{id}:
    get:
      tags:
        - "Vault"
      summary: "Read a decrypted vault value"
      description: "Reads a vault entry with a decrypted value field. If `required_group` value of the stored vault entry is not emtpy,\n
      only users of this group can read this value."
      produces:
        - "application/json"
      parameters:
        - in: "path"
          name: "id"
          required: true
          description: "Unique vault entry ID"
          type: "integer"
      responses:
        "200":
          description: "Successful Operation"
          schema:
            type: "object"
            properties:
              data:
                type: "object"
                $ref: "#/definitions/VaultEntryOutputFull"
        "401":
          description: "Unauthorized"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "403":
          description: "your group doesn't allow access to this value"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "404":
          description: "Cannot find a vault entry by the provided id"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "409":
          description: "vault is locked or not initialized"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "500":
          description: "Invalid Operation"
          schema:
            $ref: "#/definitions/ErrorPayload"
    put:
      tags:
        - "Vault"
      summary: "Updates an existing vault entry"
      description: "Updates an existing vault entry by the provided `id` parameter.\n
      If `required_group` value of the stored vault entry is not empty, only users of this group can change this value.\n
      You need to provide all fields like those you used to create a vault entry. Partial updates are not supported.
      You can get `id` it by using the listing API. You get the id also when you store a new value."
      parameters:
        - in: "path"
          name: "id"
          required: true
          description: "Unique vault entry ID"
          type: "integer"
        - in: "body"
          name: "body"
          description: "value in the json format"
          required: true
          schema:
            $ref: "#/definitions/VaultEntryInput"
      responses:
        "200":
          description: "Successful Operation"
          schema:
            type: "object"
            properties:
              data:
                type: "object"
                properties:
                  id:
                    type: "integer"
                    description: "unique internal id of the updated vault entry"
        "400":
          description: "Invalid body parameters"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "401":
          description: "Unauthorized"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "403":
          description: "your group doesn't allow access to this value"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "409":
          description: "vault is locked or not initialized"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "500":
          description: "Invalid Operation"
          schema:
            $ref: "#/definitions/ErrorPayload"
    delete:
      tags:
        - "Vault"
      summary: "Deletes an existing vault entry"
      description: "Delete a vault entry by the provided `id` parameter.\n
      If `required_group` value of the stored vault entry is not empty, only users of this group can delete this value."
      parameters:
        - in: "path"
          name: "id"
          required: true
          description: "Unique vault entry ID"
          type: "integer"
      responses:
        "204":
          description: "Successful Operation"
        "401":
          description: "Unauthorized"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "403":
          description: "your group doesn't allow access to this value"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "404":
          description: "cannot find this entry by the provided id"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "409":
          description: "vault is locked or not initialized"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "500":
          description: "Invalid Operation"
          schema:
            $ref: "#/definitions/ErrorPayload"

  /vault-admin/init:
    post:
      tags:
        - "Vault"
      summary: "Initialize vault"
      description: "Initializes vault database and stores password for further requests.
      This API requires the current user to be member of group `Administrators`. Returns 403 otherwise.
      The `Administrators` group name is hardcoded and cannot be changed at the moment"
      produces:
        - "application/json"
      parameters:
        - in: "body"
          name: "password"
          description: "Password to unlock the vault"
          required: true
          schema:
            $ref: '#/definitions/SinglePassword'
      responses:
        "201":
          description: "Successful Operation"
        "409":
          description: "vault is already initialized"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "400":
          description: "Password is too short or too long"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "403":
          description: "current user should belong to Administrators group to access this resource"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "500":
          description: "Invalid Operation"
          schema:
            $ref: "#/definitions/ErrorPayload"
  /vault-admin/sesame:
    delete:
      tags:
        - "Vault"
      summary: "Locks vault"
      description: "Locks vault and delets it's password from server's memory.
      This API requires the current user to be member of group `Administrators`. Returns 403 otherwise.
            The `Administrators` group name is hardcoded and cannot be changed at the moment"
      produces:
        - "application/json"
      responses:
        "204":
          description: "Successful Operation"
        "403":
          description: "current user should belong to Administrators group to access this resource"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "409":
          description: "vault is already locked"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "500":
          description: "Invalid Operation"
          schema:
            $ref: "#/definitions/ErrorPayload"
    post:
      tags:
        - "Vault"
      summary: "Unlock vault"
      description: "Unlocks vault to make it functional. If vault is locked, it won't accept any API requests.
       This API requires the current user to be member of group `Administrators`. Returns 403 otherwise.
       The `Administrators` group name is hardcoded and cannot be changed at the moment"
      produces:
        - "application/json"
      parameters:
        - in: "body"
          name: "password"
          description: "Password to unlock the vault. It should be the same password, which was provided when the vault was initialized."
          required: true
          schema:
            $ref: '#/definitions/SinglePassword'
      responses:
        "201":
          description: "Successful Operation"
        "401":
          description: "wrong password provided"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "409":
          description: "vault is already unlocked"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "403":
          description: "current user should belong to Administrators group to access this resource"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "500":
          description: "Invalid Operation"
          schema:
            $ref: "#/definitions/ErrorPayload"
  /library/scripts:
    get:
      tags:
        - "Library"
      summary: "Read or find scripts"
      description: "Reads all scripts or find some based on the input parameters"
      produces:
        - "application/json"
      parameters:
        - in: "query"
          name: "sort"
          description: "Sort field to be used for values, the sorting direction is by default ASC.\n
            To change the direction add `-` to the sorting value e.g. `-id`. Allowed values are `id`, `name`, `created_by`, `created_at`.\n
            You can use as many sort parameters as you want."
          required: false
          type: "string"
        - in: "query"
          name: "filter[<FIELD>]"
          description: "Filter to find scripts. It should be provided in the format as `filter[<FIELD>]=<VALUE>`,\n
              where `<FIELD>` is one of the values `id`, `name`, `created_by`, `created_at` and `<VALUE>` is the search value,\n
              e.g. `filter[created_by]=admin` will request only scripts created by admin. You can use as many filter parameters as you want.\n
              If you want to filter by multiple values e.g. find entries either for name = script1 or script2 you can use following filters\n
              `filter[name]=script1,script2`."
          required: false
          type: "string"
        - in: "query"
          name: "fields[<RESOURCE>]"
          description: "Fields to be returned. It should be provided in the format as `fields[<RESOURCE>]=<FIELDS>`,
              where `<RESOURCE>` is `scripts` and `<FIELDS>` is a comma separated list of fields. Example: `fields[scripts]=id,name`.
              If no fields are specified, all will be returned."
          required: false
          type: "string"
      responses:
        "200":
          description: "Successful Operation"
          schema:
            type: "object"
            properties:
              data:
                type: "array"
                items:
                  $ref: "#/definitions/Script"
        "400":
          description: "unsupported sort field 'xyz'"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "401":
          description: "Unauthorized"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "500":
          description: "Invalid Operation"
          schema:
            $ref: "#/definitions/ErrorPayload"
    post:
      tags:
        - "Library"
      summary: "Creates a new script"
      description: "Creates a new script.\n
        If another entry with the same name exists, an error will be returned."
      produces:
        - "application/json"
      parameters:
        - in: "body"
          name: "body"
          description: "value in the json format"
          required: true
          schema:
            $ref: "#/definitions/ScriptInput"
      responses:
        "201":
          description: "Successful Create Operation"
          schema:
            type: "object"
            properties:
              data:
                type: "object"
                $ref: "#/definitions/Script"
        "400":
          description: "Invalid request parameters"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "401":
          description: "Unauthorized"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "409":
          description: "another script with the same name exists"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "500":
          description: "Invalid Operation"
          schema:
            $ref: "#/definitions/ErrorPayload"
  /library/scripts/{id}:
    get:
      tags:
        - "Library"
      summary: "Read a script"
      description: "Reads a script by the provided ID"
      produces:
        - "application/json"
      parameters:
        - in: "path"
          name: "id"
          required: true
          description: "Unique script ID"
          type: "string"
        - in: "query"
          name: "fields[<RESOURCE>]"
          description: "Fields to be returned. It should be provided in the format as `fields[<RESOURCE>]=<FIELDS>`,
              where `<RESOURCE>` is `scripts` and `<FIELDS>` is a comma separated list of fields. Example: `fields[scripts]=id,name`.
              If no fields are specified, all will be returned."
          required: false
          type: "string"
      responses:
        "200":
          description: "Successful Operation"
          schema:
            type: "object"
            properties:
              data:
                type: "object"
                $ref: "#/definitions/Script"
        "401":
          description: "Unauthorized"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "404":
          description: "Cannot find a script by the provided id"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "500":
          description: "Invalid Operation"
          schema:
            $ref: "#/definitions/ErrorPayload"
    put:
      tags:
        - "Library"
      summary: "Updates an existing script"
      description: "Updates an existing script by the provided `id` parameter.\n
      You need to provide all fields like those you used to create a script. Partial updates are not supported.
      You can get `id` by using the listing API. You get the id also when you store a new value."
      parameters:
        - in: "path"
          name: "id"
          required: true
          description: "Unique script ID"
          type: "string"
        - in: "body"
          name: "body"
          description: "value in the json format"
          required: true
          schema:
            $ref: "#/definitions/ScriptInput"
      responses:
        "200":
          description: "Successful Operation"
          schema:
            type: "object"
            properties:
              data:
                type: "object"
                $ref: "#/definitions/Script"
        "400":
          description: "Invalid body parameters"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "401":
          description: "Unauthorized"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "409":
          description: "another script with the same name exists"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "500":
          description: "Invalid Operation"
          schema:
            $ref: "#/definitions/ErrorPayload"
    delete:
      tags:
        - "Library"
      summary: "Deletes an existing script"
      description: "Delete a script by the provided `id` parameter."
      parameters:
        - in: "path"
          name: "id"
          required: true
          description: "Unique script ID"
          type: "string"
      responses:
        "204":
          description: "Successful Operation"
        "401":
          description: "Unauthorized"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "404":
          description: "cannot find script by the provided id"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "500":
          description: "Invalid Operation"
          schema:
            $ref: "#/definitions/ErrorPayload"
  /library/commands:
    get:
      tags:
        - "Library"
      summary: "List commands"
      description: "Reads all commands or find some based on the input parameters"
      produces:
        - "application/json"
      parameters:
        - in: "query"
          name: "sort"
          description: "Sort field to be used for values, the sorting direction is by default ASC.\n
            To change the direction add `-` to the sorting value e.g. `-id`. Allowed values are `id`, `name`, `created_by`, `created_at`, `updated_by`, `updated_at`.\n
            You can use as many sort parameters as you want."
          required: false
          type: "string"
        - in: "query"
          name: "filter[<FIELD>]"
          description: "Filter to find commands. It should be provided in the format as `filter[<FIELD>]=<VALUE>`,\n
              where `<FIELD>` is one of the values `id`, `name`, `created_by`, `created_at`, `updated_by`, `updated_at` and `<VALUE>` is the search value,\n
              e.g. `filter[created_by]=admin` will request only commands created by admin. You can use as many filter parameters as you want.\n
              If you want to filter by multiple values e.g. find entries either for name = command1 or command2 you can use following filters\n
              `filter[name]=command1,command2`."
          required: false
          type: "string"
        - in: "query"
          name: "fields[<RESOURCE>]"
          description: "Fields to be returned. It should be provided in the format as `fields[<RESOURCE>]=<FIELDS>`,
              where `<RESOURCE>` is `comamnds` and `<FIELDS>` is a comma separated list of fields. Example: `fields[commands]=id,name`.
              If no fields are specified, all will be returned."
          required: false
          type: "string"
      responses:
        "200":
          description: "Successful Operation"
          schema:
            type: "object"
            properties:
              data:
                type: "array"
                items:
                  $ref: "#/definitions/Command"
        "400":
          description: "unsupported sort field 'xyz'"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "401":
          description: "Unauthorized"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "500":
          description: "Invalid Operation"
          schema:
            $ref: "#/definitions/ErrorPayload"
    post:
      tags:
        - "Library"
      summary: "Creates a new command"
      description: "Creates a new command.\n
        If another entry with the same name exists, an error will be returned."
      produces:
        - "application/json"
      parameters:
        - in: "body"
          name: "body"
          description: "value in the json format"
          required: true
          schema:
            $ref: "#/definitions/CommandInput"
      responses:
        "201":
          description: "Successful Create Operation"
          schema:
            type: "object"
            properties:
              data:
                type: "object"
                $ref: "#/definitions/Command"
        "400":
          description: "Invalid request parameters"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "401":
          description: "Unauthorized"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "409":
          description: "another script with the same name exists"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "500":
          description: "Invalid Operation"
          schema:
            $ref: "#/definitions/ErrorPayload"
  /library/commands/{id}:
    get:
      tags:
        - "Library"
      summary: "Read a command"
      description: "Reads a command by the provided ID"
      produces:
        - "application/json"
      parameters:
        - in: "path"
          name: "id"
          required: true
          description: "Unique command ID"
          type: "string"
        - in: "query"
          name: "fields[<RESOURCE>]"
          description: "Fields to be returned. It should be provided in the format as `fields[<RESOURCE>]=<FIELDS>`,
              where `<RESOURCE>` is `commands` and `<FIELDS>` is a comma separated list of fields. Example: `fields[commands]=id,name`.
              If no fields are specified, all will be returned."
          required: false
          type: "string"
      responses:
        "200":
          description: "Successful Operation"
          schema:
            type: "object"
            properties:
              data:
                type: "object"
                $ref: "#/definitions/Command"
        "401":
          description: "Unauthorized"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "404":
          description: "Cannot find a command by the provided id"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "500":
          description: "Invalid Operation"
          schema:
            $ref: "#/definitions/ErrorPayload"
    put:
      tags:
        - "Library"
      summary: "Updates an existing command"
      description: "Updates an existing command by the provided `id` parameter.\n
      You need to provide all fields like those you used to create a command. Partial updates are not supported.
      You can get `id` by using the listing API. You get the id also when you store a new value."
      parameters:
        - in: "path"
          name: "id"
          required: true
          description: "Unique command ID"
          type: "string"
        - in: "body"
          name: "body"
          description: "value in the json format"
          required: true
          schema:
            $ref: "#/definitions/CommandInput"
      responses:
        "200":
          description: "Successful Operation"
          schema:
            type: "object"
            properties:
              data:
                type: "object"
                $ref: "#/definitions/Command"
        "400":
          description: "Invalid body parameters"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "401":
          description: "Unauthorized"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "409":
          description: "another command with the same name exists"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "500":
          description: "Invalid Operation"
          schema:
            $ref: "#/definitions/ErrorPayload"
    delete:
      tags:
        - "Library"
      summary: "Deletes an existing command"
      description: "Delete a command by the provided `id` parameter."
      parameters:
        - in: "path"
          name: "id"
          required: true
          description: "Unique command ID"
          type: "string"
      responses:
        "204":
          description: "Successful Operation"
        "401":
          description: "Unauthorized"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "404":
          description: "cannot find command by the provided id"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "500":
          description: "Invalid Operation"
          schema:
            $ref: "#/definitions/ErrorPayload"
  /auditlog:
    get:
      tags:
        - "Audit Log"
      summary: "List auditlog entries"
      description: "List auditlog entries using the provided filters"
      produces:
        - "application/json"
      parameters:
        - name: "sort"
          in: "query"
          description: Sort option `-<field>`(desc) or `<field>`(asc). `<field>` can be one of `'timestamp', 'username', 'remote_ip', 'application', 'action', 'affected_id', 'client_id', 'client_hostname'`. For example, `&sort=-timestamp`.
          required: false
          type: "string"
        - name: "filter"
          in: "query"
          description: Filter option `filter[<field>]` or `filter[timestamp][<op>]`.
            `<field>` can be one of `'username', 'remote_ip', 'application', 'action', 'affected_id', 'client_id', 'client_hostname'`.
            For example, `&filter[username]=admin` or `filter[timestamp][gt]=2021-10-28`, etc.
            Multiple filters are possible.
          required: false
          type: "string"
        - name: "page"
          in: "query"
          required: false
          type: "integer"
          description: Pagination options `page[limit]` and `page[offset]` can be used to get more than the first page of results. Default limit is 10 and maximum is 100. The `count` property in meta shows the total number of results.
      responses:
        "200":
          description: "Successful Operation"
          schema:
            type: "object"
            properties:
              data:
                type: "array"
                items:
                  $ref: "#/definitions/AuditLog"
              meta:
                type: "object"
                properties:
                  count:
                    type: "integer"
        "401":
          description: "Unauthorized"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "500":
          description: "Invalid Operation"
          schema:
            $ref: "#/definitions/ErrorPayload"
  /me/totp-secret:
    get:
      tags:
        - "Profile & Info"
      summary: "Read secret key and qr for an Authenticator app"
      description: "Shows secret key and qr image in base64 format for an Authenticator app. Requires a token received from `/verify-2fa` endpoint."
      produces:
        - "application/json"
      responses:
        "200":
          description: "Successful Operation"
          schema:
            $ref: "#/definitions/TotP"
        "400":
          description: "TotP is disabled"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "401":
          description: "Unauthorized, wrong token type provided (e.g. the one received from /login endpoint)"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "404":
          description: "time based one time secret key should be generated for this user"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "500":
          description: "Invalid Operation"
          schema:
            $ref: "#/definitions/ErrorPayload"
    post:
      tags:
        - "Profile & Info"
      summary: "Creates a new secret key for an Authenticator app"
      description: "Creates a new secret key for an Authenticator app only for the first time! If another totP secret already exists for this user, an error will appear. Requires a valid JWT token received from the `/login` endpoint."
      produces:
        - "application/json"
      responses:
        "200":
          description: "Successful Operation"
          schema:
            $ref: "#/definitions/TotP"
        "400":
          description: "TotP is disabled"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "401":
          description: "Unauthorized or totP secret is already created"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "500":
          description: "Invalid Operation"
          schema:
            $ref: "#/definitions/ErrorPayload"
    delete:
      tags:
        - "Profile & Info"
      summary: "Delete time based one time secret key of the current user. Requires a token received from `/verify-2fa` endpoint."
      responses:
        "204":
          description: "Successful operation."
        "400":
          description: "TotP is disabled"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "401":
          description: "Unauthorized, wrong token type provided (e.g. the one received from /login endpoint)"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "500":
          description: "Invalid Operation"
          schema:
            $ref: "#/definitions/ErrorPayload"

  /clients/{client_id}/graph-metrics:
    get:
      tags:
        - "Monitoring"
      summary: "Lists client metrics for displaying as graphs"
      description: "List downsampled monitoring data about client metrics for the provided clientID"
      produces:
        - "application/json"
      parameters:
        - in: "path"
          name: "client_id"
          required: true
          description: "Unique client ID"
          type: "string"
        - in: "query"
          name: "sort"
          description: "There is only `timestamp` allowed as sort field. Default direction is DESC\n
            To sort ascending use `&sort=timestamp`."
          required: false
          type: "string"
        - in: "query"
          name: "filter[timestamp][<OPERATOR>]"
          description: "Filter entries by field `timestamp`. `<OPERATOR>` can be one of `gt`, `lt`, `since` or `until`.\n
              `gt` and `lt` require a timestamp value as `unixepoch`. `since` and `until` require a timestamp value in format `RFC3339`.\n
              e.g. `filter[timestamp][gt]=1636009200&filter[timestamp][lt]=1636009500` or\n
              e.g. `filter[timestamp][since]=2021-01-01T00:00:00+01:00&filter[timestamp][until]=2021-01-01T01:00:00+01:00`.\n\n
              Downsampling data is available for a period `>= 2 hours` and `<= 48 hours`.\n
              When downsampling takes place you get `avg, min and max` values for `cpu_usage_percent, memory_usage_percent and io_usage_percent`\n\n
              "
          required: false
          type: "string"
      responses:
        "200":
          description: "Successful Operation"
          schema:
            type: "object"
            properties:
              data:
                type: "array"
                items:
                  $ref: "#/definitions/GraphMetrics"
              links:
                type: "object"
                properties:
                  cpu_usage_percent:
                    type: "string"
                  mem_usage_percent:
                    type: "string"
                  io_usage_percent:
                    type: "string"
                  net_usage_percent_lan:
                    type: "string"
                  net_usage_bps_lan:
                    type: "string"
                  net_usage_percent_wan:
                    type: "string"
                  net_usage_bps_wan:
                    type: "string"
        "400":
          description: "Bad Request"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "404":
          description: "Cannot find measurements by the provided id"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "500":
          description: "Invalid Operation"
          schema:
            $ref: "#/definitions/ErrorPayload"

  /clients/{client_id}/graph-metrics/{graph_name}:
    get:
      tags:
        - "Monitoring"
      summary: "Lists client metrics for given graph name"
      description: "List downsampled monitoring data about client metrics for the provided clientID and graph name"
      produces:
        - "application/json"
      parameters:
        - in: "path"
          name: "client_id"
          required: true
          description: "Unique client ID"
          type: "string"
        - in: "path"
          name: "graph_name"
          required: true
          description: "Unique graph name \n
          Possible values are `cpu_usage_percent`, `mem_usage_percent`, `io_usage_percent`, `net_usage_percent_lan`, `net_usage_bps_lan`,\n
          `net_usage_percent_wan`, `net_usage_bps_wan`"
          type: "string"
        - in: "query"
          name: "sort"
          description: "There is only `timestamp` allowed as sort field. Default direction is DESC\n
            To sort ascending use `&sort=timestamp`."
          required: false
          type: "string"
        - in: "query"
          name: "filter[timestamp][<OPERATOR>]"
          description: "Filter entries by field `timestamp`. `<OPERATOR>` can be one of `gt`, `lt`, `since` or `until`.\n
              `gt` and `lt` require a timestamp value as `unixepoch`. `since` and `until` require a timestamp value in format `RFC3339`.\n
              e.g. `filter[timestamp][gt]=1636009200&filter[timestamp][lt]=1636009500` or\n
              e.g. `filter[timestamp][since]=2021-01-01T00:00:00+01:00&filter[timestamp][until]=2021-01-01T01:00:00+01:00`.\n\n
              Downsampling data is available for a period `>= 2 hours` and `<= 48 hours`.\n
              When downsampling takes place you get `avg, min and max` values for one of `cpu_usage_percent, memory_usage_percent, io_usage_percent`,
              `net_usage_percent_lan`, `net_usage_bps_lan`, `net_usage_percent_wan` or `net_usage_bps_wan`\n\n
              "
          required: false
          type: "string"
      responses:
        "200":
          description: "Successful Operation"
          schema:
            type: "object"
            properties:
              data:
                type: "array"
                items:
                  $ref: "#/definitions/GraphMetricsGraph"
        "400":
          description: "Bad Request"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "404":
          description: "Cannot find measurements by the provided id"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "500":
          description: "Invalid Operation"
          schema:
            $ref: "#/definitions/ErrorPayload"

  /clients/{client_id}/metrics:
    get:
      tags:
        - "Monitoring"
      summary: "Lists client metrics"
      description: "List monitoring data about client metrics for the provided clientID"
      produces:
        - "application/json"
      parameters:
        - in: "path"
          name: "client_id"
          required: true
          description: "Unique client ID"
          type: "string"
        - in: "query"
          name: "sort"
          description: "There is only `timestamp` allowed as sort field. Default direction is DESC\n
            To sort ascending use `&sort=timestamp`."
          required: false
          type: "string"
        - in: "query"
          name: "filter[timestamp][<OPERATOR>]"
          description: "Filter entries by field `timestamp`. `<OPERATOR>` can be one of `gt`, `lt`, `since` or `until`.\n
              `gt` and `lt` require a timestamp value as `unixepoch`. `since` and `until` require a timestamp value in format `RFC3339`.\n
              e.g. `filter[timestamp][gt]=1636009200&filter[timestamp][lt]=1636009500` or\n
              e.g. `filter[timestamp][since]=2021-01-01T00:00:00+01:00&filter[timestamp][until]=2021-01-01T01:00:00+01:00`.\n\n
              "
          required: false
          type: "string"
        - in: "query"
          name: "fields[<RESOURCE>]"
          description: "Fields to be returned. It should be provided in the format as `fields[<RESOURCE>]=<FIELDS>`,
              where `<RESOURCE>` is `metrics` and `<FIELDS>` is a comma separated list of fields. Example: `fields[metrics]=timestamp,cpu_usage_percent,memory_usage_percent,io_usage_percent`.
              If no fields are specified, `timestamp, cpu_usage_percent, memory_usage_percent and io_usage_percent` are returned."
          required: false
          type: "string"
        - name: "page"
          in: "query"
          required: false
          type: "integer"
          description: "Pagination options `page[limit]` and `page[offset]` can be used to get more than the first page of results. Default limit is 1 and maximum is 120.\n The `count` property in meta shows the total number of results."
      responses:
        "200":
          description: "Successful Operation"
          schema:
            type: "object"
            properties:
              data:
                type: "array"
                items:
                  $ref: "#/definitions/Metrics"
              meta:
                type: "object"
                properties:
                  count:
                    type: "integer"
        "400":
          description: "Bad Request"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "404":
          description: "Cannot find measurements by the provided id"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "500":
          description: "Invalid Operation"
          schema:
            $ref: "#/definitions/ErrorPayload"

  /clients/{client_id}/mountpoints:
    get:
      tags:
        - "Monitoring"
      summary: "Lists client mountpoints"
      description: "List monitoring data about client mountpoints for the provided clientID"
      produces:
        - "application/json"
      parameters:
        - in: "path"
          name: "client_id"
          required: true
          description: "Unique client ID"
          type: "string"
        - in: "query"
          name: "sort"
          description: "There is only `timestamp` allowed as sort field. Default direction is DESC\n
            To sort ascending use `&sort=timestamp`."
          required: false
          type: "string"
        - in: "query"
          name: "filter[timestamp][<OPERATOR>]"
          description: "Filter entries by field `timestamp`. `<OPERATOR>` can be one of `gt`, `lt`, `since` or `until`.\n
              `gt` and `lt` require a timestamp value as `unixepoch`. `since` and `until` require a timestamp value in format `RFC3339`.\n
              e.g. `filter[timestamp][gt]=1636009200&filter[timestamp][lt]=1636009500` or\n
              e.g. `filter[timestamp][since]=2021-01-01T00:00:00+01:00&filter[timestamp][until]=2021-01-01T01:00:00+01:00`.\n\n
              "
          required: false
          type: "string"
        - name: "page"
          in: "query"
          required: false
          type: "integer"
          description: "Pagination options `page[limit]` and `page[offset]` can be used to get more than the first page of results. Default limit is 1 and maximum is 100.\n
          The `count` property in meta shows the total number of results."
      responses:
        "200":
          description: "Successful Operation"
          schema:
            type: "object"
            properties:
              data:
                type: "array"
                items:
                  $ref: "#/definitions/Mountpoints"
              meta:
                type: "object"
                properties:
                  count:
                    type: "integer"
        "400":
          description: "Bad Request"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "404":
          description: "Cannot find measurements by the provided id"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "500":
          description: "Invalid Operation"
          schema:
            $ref: "#/definitions/ErrorPayload"

  /clients/{client_id}/processes:
    get:
      tags:
        - "Monitoring"
      summary: "Lists client processes"
      description: "List monitoring data about client processes for the provided clientID"
      produces:
        - "application/json"
      parameters:
        - in: "path"
          name: "client_id"
          required: true
          description: "Unique client ID"
          type: "string"
        - in: "query"
          name: "sort"
          description: "There is only `timestamp` allowed as sort field. Default direction is DESC\n
            To sort ascending use `&sort=timestamp`."
          required: false
          type: "string"
        - in: "query"
          name: "filter[timestamp][<OPERATOR>]"
          description: "Filter entries by field `timestamp`. `<OPERATOR>` can be one of `gt`, `lt`, `since` or `until`.\n
              `gt` and `lt` require a timestamp value as `unixepoch`. `since` and `until` require a timestamp value in format `RFC3339`.\n
              e.g. `filter[timestamp][gt]=1636009200&filter[timestamp][lt]=1636009500` or\n
              e.g. `filter[timestamp][since]=2021-01-01T00:00:00+01:00&filter[timestamp][until]=2021-01-01T01:00:00+01:00`.\n\n
              Fetching data for a period greater than `48 hours` is not allowed. If the period exceeds `2 hours`, than the returned measurement points get downsampled to reduce the amount of data.\n
              When downsampling takes place you get `average, min and max` values for `cpu_usage_percent, memory_usage_percent and io_usage_percent`\n\n
              "
          required: false
          type: "string"
        - name: "page"
          in: "query"
          required: false
          type: "integer"
          description: "Pagination options `page[limit]` and `page[offset]` can be used to get more than the first page of results. Default limit is 1 and maximum is 10.\n The `count` property in meta shows the total number of results."
      responses:
        "200":
          description: "Successful Operation"
          schema:
            type: "object"
            properties:
              data:
                type: "array"
                items:
                  $ref: "#/definitions/Processes"
              meta:
                type: "object"
                properties:
                  count:
                    type: "integer"
        "400":
          description: "Bad Request"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "404":
          description: "Cannot find measurements by the provided id"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "500":
          description: "Invalid Operation"
          schema:
            $ref: "#/definitions/ErrorPayload"
  /clients/{client_id}/stored-tunnels:
    get:
      tags:
        - "Clients and Tunnels"
      summary: "List stored tunnels"
      produces:
        - "application/json"
      parameters:
        - in: "path"
          name: "client_id"
          required: true
          description: "Unique client ID"
          type: "string"
        - in: "query"
          name: "sort"
          description: "Sort field to be used for sorting, the sorting direction is by default ASC.\n
            To change the direction add `-` to the sorting value e.g. `-id`. Allowed values are `created_at`, `name`, `scheme`, `remote_ip`, `remote_port`.\n
            You can use as many sort parameters as you want."
          required: false
          type: "string"
        - in: "query"
          name: "filter[<FIELD>]"
          description: "Filter to find stored tunnels. It should be provided in the format as `filter[<FIELD>]=<VALUE>`,\n
              where `<FIELD>` is one of the values `name`, `scheme`, `remote_ip`, `remote_port` and `<VALUE>` is the search value,\n
              e.g. `filter[scheme]=https` will request only stored tunnels with scheme https. You can use as many filter parameters as you want.\n
              If you want to filter by multiple values e.g. find entries either for scheme = http or https you can use following filters\n
              `filter[scheme]=http,https`."
          required: false
          type: "string"
        - name: "page"
          in: "query"
          required: false
          type: "integer"
          description: "Pagination options `page[limit]` and `page[offset]` can be used to get more than the first page of results. Default limit is 10 and maximum is 100.\n The `count` property in meta shows the total number of results."
      responses:
        "200":
          description: "Successful Operation"
          schema:
            type: "object"
            properties:
              data:
                type: "array"
                items:
                  $ref: "#/definitions/StoredTunnel"
              meta:
                type: "object"
                properties:
                  count:
                    type: "integer"
        "400":
          description: "unsupported sort field 'xyz'"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "401":
          description: "Unauthorized"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "500":
          description: "Invalid Operation"
          schema:
            $ref: "#/definitions/ErrorPayload"
    post:
      tags:
        - "Clients and Tunnels"
      summary: "Creates a new stored tunnel"
      produces:
        - "application/json"
      parameters:
        - in: "path"
          name: "client_id"
          required: true
          description: "Unique client ID"
          type: "string"
        - in: "body"
          name: "body"
          description: "value in the json format"
          required: true
          schema:
            $ref: "#/definitions/StoredTunnel"
      responses:
        "201":
          description: "Successful Create Operation"
          schema:
            type: "object"
            properties:
              data:
                type: "object"
                $ref: "#/definitions/StoredTunnel"
        "400":
          description: "Invalid request parameters"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "401":
          description: "Unauthorized"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "409":
          description: "another script with the same name exists"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "500":
          description: "Invalid Operation"
          schema:
            $ref: "#/definitions/ErrorPayload"
  /clients/{client_id}/stored-tunnels/{id}:
    put:
      tags:
        - "Clients and Tunnels"
      summary: "Updates an existing stored tunnel"
      description: "Updates an existing stored tunnel by the provided `id` parameter.\n
      You need to provide all fields like those you used to create the stored tunnel. Partial updates are not supported.
      You can get `id` by using the listing API. You get the id also when you store a new value."
      parameters:
        - in: "path"
          name: "client_id"
          required: true
          description: "Unique client ID"
          type: "string"
        - in: "path"
          name: "id"
          required: true
          description: "Unique script ID"
          type: "string"
        - in: "body"
          name: "body"
          description: "value in the json format"
          required: true
          schema:
            $ref: "#/definitions/StoredTunnel"
      responses:
        "200":
          description: "Successful Operation"
          schema:
            type: "object"
            properties:
              data:
                type: "object"
                $ref: "#/definitions/StoredTunnel"
        "400":
          description: "Invalid body parameters"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "401":
          description: "Unauthorized"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "500":
          description: "Invalid Operation"
          schema:
            $ref: "#/definitions/ErrorPayload"
    delete:
      tags:
        - "Clients and Tunnels"
      summary: "Deletes an existing stored tunnel"
      parameters:
        - in: "path"
          name: "client_id"
          required: true
          description: "Unique client ID"
          type: "string"
        - in: "path"
          name: "id"
          required: true
          description: "Unique stored tunnel ID"
          type: "string"
      responses:
        "204":
          description: "Successful Operation"
        "401":
          description: "Unauthorized"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "404":
          description: "cannot find stored tunnel by the provided id"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "500":
          description: "Invalid Operation"
          schema:
            $ref: "#/definitions/ErrorPayload"
  /schedules:
    get:
      tags:
        - "Jobs"
      summary: "List schedules"
      description: "Reads all schedules or find some based on the input parameters"
      produces:
        - "application/json"
      parameters:
        - in: "query"
          name: "sort"
          description: "Sort field to be used for sorting, the sorting direction is by default ASC.\n
            To change the direction add `-` to the sorting value e.g. `-id`. Allowed values are `id`, `created_at`, `created_by`, `name`, `type`.\n
            You can use as many sort parameters as you want."
          required: false
          type: "string"
        - in: "query"
          name: "filter[<FIELD>]"
          description: "Filter the results. It should be provided in the format as `filter[<FIELD>]=<VALUE>`,\n
              where `<FIELD>` is one of the values `id`, `created_at`, `created_by`, `name`, `type`, `client_ids`, `group_ids` and `<VALUE>` is the search value,\n
              e.g. `filter[name]=Schedule` will request only schedule with name Schedule. You can use as many filter parameters as you want.\n
              If you want to filter by multiple values e.g. find entries either for name = Schedule or Other you can use following filters\n
              `filter[name]=Schedule,Other`."
          required: false
          type: "string"
        - name: "page"
          in: "query"
          required: false
          type: "integer"
          description: Pagination options `page[limit]` and `page[offset]` can be used to get more than the first page of results. Default limit is 20 and maximum is 100. The `count` property in meta shows the total number of results.
      responses:
        "200":
          description: "Successful Operation"
          schema:
            type: "object"
            properties:
              data:
                type: "array"
                items:
                  $ref: "#/definitions/Schedule"
              meta:
                type: "object"
                properties:
                  count:
                    type: "integer"
        "400":
          description: "unsupported sort field 'xyz'"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "401":
          description: "Unauthorized"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "500":
          description: "Invalid Operation"
          schema:
            $ref: "#/definitions/ErrorPayload"
    post:
      tags:
        - "Jobs"
      summary: "Creates a new schedule"
      description: "Creates a new schedule."
      produces:
        - "application/json"
      parameters:
        - in: "body"
          name: "body"
          description: "value in the json format"
          required: true
          schema:
            $ref: "#/definitions/Schedule"
      responses:
        "201":
          description: "Successful Create Operation"
          schema:
            type: "object"
            properties:
              data:
                type: "object"
                $ref: "#/definitions/Schedule"
        "400":
          description: "Invalid request parameters"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "401":
          description: "Unauthorized"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "500":
          description: "Invalid Operation"
          schema:
            $ref: "#/definitions/ErrorPayload"
  /schedules/{id}:
    get:
      tags:
        - "Jobs"
      summary: "Get a schedule"
      description: "Get a schedule by the provided ID"
      produces:
        - "application/json"
      parameters:
        - in: "path"
          name: "id"
          required: true
          description: "Unique schedule ID"
          type: "string"
      responses:
        "200":
          description: "Successful Operation"
          schema:
            type: "object"
            properties:
              data:
                type: "object"
                $ref: "#/definitions/Schedule"
        "401":
          description: "Unauthorized"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "404":
          description: "Cannot find a schedule by the provided id"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "500":
          description: "Invalid Operation"
          schema:
            $ref: "#/definitions/ErrorPayload"
    put:
      tags:
        - "Jobs"
      summary: "Updates an existing schedule"
      description: "Updates an existing schedule by the provided `id` parameter.\n
      You need to provide all fields like those you used to create a schedule. Partial updates are not supported.
      You can get `id` by using the listing API. You get the id also when you store a new value."
      parameters:
        - in: "path"
          name: "id"
          required: true
          description: "Unique schedule ID"
          type: "string"
        - in: "body"
          name: "body"
          description: "value in the json format"
          required: true
          schema:
            $ref: "#/definitions/Schedule"
      responses:
        "200":
          description: "Successful Operation"
          schema:
            type: "object"
            properties:
              data:
                type: "object"
                $ref: "#/definitions/Schedule"
        "400":
          description: "Invalid body parameters"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "401":
          description: "Unauthorized"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "500":
          description: "Invalid Operation"
          schema:
            $ref: "#/definitions/ErrorPayload"
    delete:
      tags:
        - "Jobs"
      summary: "Deletes an existing schedule"
      description: "Delete a schedule by the provided `id` parameter."
      parameters:
        - in: "path"
          name: "id"
          required: true
          description: "Unique schedule ID"
          type: "string"
      responses:
        "204":
          description: "Successful Operation"
        "401":
          description: "Unauthorized"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "404":
          description: "cannot find command by the provided id"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "500":
          description: "Invalid Operation"
          schema:
            $ref: "#/definitions/ErrorPayload"
  /files:
    post:
      tags:
        - "Upload"
      summary: "Upload file"
      description: "Handles file uploads as a multipart/form-data. Files are stored on the rport server in a temp location.\n
      Then all specified clients download them by sftp protocol to a temp location as well. \n
      If download was successful, clients move the temp file to the destination path"
      consumes:
        - "multipart/form-data"
      parameters:
        - in: "formData"
          name: "upload"
          type: "file"
          required: true
          description: "The file to upload"
        - in: "formData"
          name: "client_id"
          type: "string"
          required: true
          description: "Client ID where the file should be placed. You can repeat 'client' parameter to indicate multiple clients"
        - in: "formData"
          name: "group_id"
          type: "string"
          required: false
          description: "ID of a client group where the file should be placed. You can repeat 'group_id' parameter to indicate multiple groups"
        - in: "formData"
          name: "dest"
          type: "string"
          required: true
          description: "Absolute path with the file name on the client where the file should be placed"
        - in: "formData"
          name: "force"
          type: "string"
          required: false
          default: ""
          description: "If true, rport client will overwrite destination file if it exists or fail otherwise.\n
          You can provide values like true or 1 or on to enable this flag"
        - in: "formData"
          name: "sync"
          type: "string"
          required: false
          default: ""
          description: "If true and the destination file exists, rport client will compare md5 checksum of the provided file \n
          with the destination file and will overwrite it if it's not matching. On Unix it will also compare file mode, owner and group \n
          of the existing file with the provided values and if they don't match, rport client will execute chmod/chown operations on the destination path. \n
          if false or file doesn't exists, the provided file will be copied to the destination."
        - in: "formData"
          name: "mode"
          type: "string"
          required: false
          default: ""
          description: "For Unix only, indicates the desired file mode of the target file on the client. If the file doesn't exist, it will be created with the provided mode. \n
          If file exists (and sync is true), rport client will run chmod operation with the provided file mode."
        - in: "formData"
          name: "user"
          type: "string"
          required: false
          default: ""
          description: "For Unix only, indicates the desired owner name the target file on the client. \n
          The uploaded file will be created with the default owner in a temp folder. If `user` is not empty, rport client will perform chown operation on the temp file. \n
          Then it will be moved to the target path Please make sure that the provided user exists on the client.\n
          Since changing owner of a file requires sudo rights, the rport client user should have the necessary permissions to chown and move file to the target location."
        - in: "formData"
          name: "group"
          type: "string"
          required: false
          default: ""
          description: "For Unix only, indicates the group name the target file on the client. \n
          The uploaded file will be created with the default group in a temp folder. Then rport client will chown the temp file with the provided group name. \n
          Then it will be moved to the target path. Please make sure that the provided group exists on the client.\n
          Since changing group of a file requires sudo rights, the rport client user should have the necessary permissions to chown and move file to the target location."
      produces:
        - "application/json"
      responses:
        "200":
          description: "Successful Operation. In this case it indicates that the file was successfully sent to the server rather than to the clients.\n
          Sending to clients is an async operation, which can be tracked with the websocket API.\n
          To see if clients have received the file as well, use `/ws/uploads` endpoint."
          schema:
            type: "object"
            properties:
              data:
                $ref: "#/definitions/ServerUploadResponse"
        "400":
          description: "Invalid parameters"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "401":
          description: "Unauthorized"
          schema:
            $ref: "#/definitions/ErrorPayload"
        "500":
          description: "Invalid Operation"
          schema:
            $ref: "#/definitions/ErrorPayload"
definitions:
  Tunnel:
    type: "object"
    properties:
      id:
        type: "string"
      client_id:
        type: "string"
      lhost:
        type: "string"
        description: "server listens to this host"
      lport:
        type: "string"
        description: "server listens to this port"
      rhost:
        type: "string"
        description: "client proxies connection to this host"
      rport:
        type: "string"
        description: "client proxies connection to this port"
      lport_random:
        type: "boolean"
        description: "True if lport was chosen automatically with a random available port."
      scheme:
        type: "string"
        description: "URI scheme."
      protocol:
        type: "string"
        description: "tcp or udp"
      acl:
        type: "string"
        description: "IP v4 addresses who is allowed to use the tunnel (ipv6 is not supported yet). For example, '142.78.90.8,201.98.123.0/24,'."
      http_proxy:
        type: "boolean"
        description: "True if tunnel proxy was created."
      host_header:
        type: "string"
        description: "host name to set as http header field 'Host'"
  Client:
    type: "object"
    properties:
      id:
        type: "string"
      name:
        type: "string"
        description: "client name"
      os:
        type: "string"
        description: "long description of client OS"
      os_full_name:
        type: "string"
        description: "short description of client OS (e.g. Microsoft Windows Server 2016 Standard)"
      os_version:
        type: "string"
        description: "version info about client's OS e.g. 10.0.14393 Build 14393"
      os_arch:
        type: "string"
        description: "client cpu architecture (ex: 386, amd64)"
      os_family:
        type: "string"
        description: "client OS family (ex: debian, alpine, Standalone Workstation)"
      os_kernel:
        type: "string"
        description: "client OS kernel (ex: linux, windows)"
      os_virtualization_system:
        type: "string"
        description: "info about the VM where client is running e.g. KVM, LXC, HyperV, VMWare, Xen"
      os_virtualization_role:
        type: "string"
        description: "role of the client in the running VM e.g. host or guest"
      hostname:
        type: "string"
        description: "client hostname"
      cpu_family:
        type: "string"
        description: "client's processor family info"
      cpu_model:
        type: "string"
        description: "client's processor model info, e.g. 85"
      cpu_vendor:
        type: "string"
        description: "processor's vendor name , e.g. Intel"
      cpu_model_name:
        type: "string"
        description: "human readable name of the client's processor model, e.g. Intel(R) Xeon(R) Silver 4110 CPU @ 2.10GHz"
      num_cpus:
        type: "integer"
        description: "Number of cpu cores in the client's machine"
      mem_total:
        type: "number"
        description: "Total memory in bytes"
      timezone:
        type: "string"
        description: "Client's timezone e.g. PDT (UTC-07:00)"
      ipv4:
        type: "array"
        items:
          type: string
        description: "list of IPv4 addresses of the client"
      ipv6:
        type: "array"
        items:
          type: string
        description: "list of IPv6 addresses of the client"
      tags:
        type: "array"
        items:
          type: string
      version:
        type: "string"
        description: "client version"
      address:
        type: "string"
        description: "client address"
      tunnels:
        type: "array"
        items:
          $ref: "#/definitions/Tunnel"
      connection_state:
        type: "string"
        enum: [connected, disconnected]
        description: "indicates whether a client is connected or disconnected"
      disconnected_at:
        type: "string"
        format: "data-time"
        description: "time when a client was disconnected. If null - it's connected"
      client_auth_id:
        type: "string"
        description: "rport client authentication ID that was used to connect to server"
      allowed_user_groups:
        type: "array"
        items:
          type: string
        description: "list of user groups that are allowed to access this client. Administrators have always full-access to all clients. Empty list prevents access for everyone except admins"
      updates_status:
        $ref: '#/definitions/UpdatesStatus'
      client_configuration:
        $ref: '#/definitions/ClientConfiguration'
  ClientConfiguration:
    type: "object"
    description: "JSON encoded information about client configuration"
  ClientGroup:
    type: "object"
    properties:
      id:
        type: "string"
        description: "Client Group ID"
      description:
        type: "string"
        description: "Client Group description"
      client_ids:
        type: "array"
        items:
          type: string
        description: "Read Only field. Shows active and disconnected clients that belong to this group."
      params:
        type: "object"
        description: "Parameters that define what clients belong to a given client group.\n

        Each parameter can be specified by:\n
        1. exact match of the property (ignoring case). For example, \"client_id\": [\"test-win2019-tk01\", \"qa-lin-ubuntu16\"]\n
        2. dynamic criteria using wildcards (ignoring case). For example, \"os_family\": [\"linux*\"]\n

        For more details please see https://oss.rport.io/docs/no04-client-groups.html\n"
        properties:
          client_id:
            type: "array"
            items:
              type: string
            description: "client ID(s)"
          name:
            type: "array"
            items:
              type: string
            description: "client name(s)"
          os:
            type: "array"
            items:
              type: string
            description: "client OS description(s)"
          os_arch:
            type: "array"
            items:
              type: string
            description: "client cpu architecture(s) (ex: 386, amd64)"
          os_family:
            type: "array"
            items:
              type: string
            description: "client OS family (ex: debian, alpine, Standalone Workstation)"
          os_kernel:
            type: "array"
            items:
              type: string
            description: "client OS kernel(s) (ex: linux, windows)"
          hostname:
            type: "array"
            items:
              type: string
            description: "client hostname(s)"
          ipv4:
            type: "array"
            items:
              type: string
            description: "client IPv4 address(es)"
          ipv6:
            type: "array"
            items:
              type: string
            description: "client IPv6 address(es)"
          tag:
            type: "array"
            items:
              type: string
            description: "client tag(s)"
          version:
            type: "array"
            items:
              type: string
            description: "client version(s)"
          address:
            type: "array"
            items:
              type: string
            description: "client address(es)"
          client_auth_id:
            type: "array"
            items:
              type: string
            description: "client auth ID(s)"
  ClientAuth:
    type: "object"
    properties:
      id:
        type: "string"
        description: "client auth ID"
      password:
        type: "string"
        description: "client auth password"
  SinglePassword:
    type: "object"
    properties:
      password:
        type: "string"
        description: "A string of printed symbols 32 and 256 bits long"
  JobStatus:
    type: "string"
    enum: &JOB_STATUS
      - "running"
      - "successful"
      - "unknown"
      - "failed"
  Job:
    type: "object"
    properties:
      jid:
        type: "string"
        description: "job ID"
      client_id:
        type: "string"
        description: "client ID"
      client_name:
        type: "string"
        description: "client name"
      pid:
        type: "integer"
        description: "process ID"
      status:
        type: "string"
        enum: *JOB_STATUS
        description: "command status"
      command:
        type: "string"
        description: "executed command"
      cwd:
        type: "string"
        description: "current working directory for an executable command"
      is_sudo:
        type: "boolean"
        description: "execute the command as a sudo user"
      interpreter:
        type: "string"
        description: "command interpreter that was used to execute the command"
      started_at:
        type: "string"
        format: "data-time"
        description: "command start time"
      finished_at:
        type: "string"
        format: "data-time"
        description: "command finish time"
      created_by:
        type: "string"
        description: "API username who run the command"
      timeout_sec:
        type: "integer"
        description: "timeout in seconds that was used to observe the command execution"
      multi_job_id:
        type: "string"
        description: "multi-client job ID. If it is set then it means this command was initiated by running a multi-client job"
      error:
        type: "string"
        description: "is non-empty when it wasn't able to execute a command on rport client"
      result:
        type: "object"
        description: "command execution result"
        properties:
          stdout:
            type: "string"
            description: "process standard output"
          stderr:
            type: "string"
            description: "process standard error"
  JobSummary:
    type: "object"
    properties:
      jid:
        type: "string"
        description: "job ID"
      status:
        type: "string"
        enum: *JOB_STATUS
        description: "command status"
      finished_at:
        type: "string"
        format: "data-time"
        description: "command finish time"
  MultiJob:
    type: "object"
    properties:
      jid:
        type: "string"
        description: "multi-client job ID"
      started_at:
        type: "string"
        format: "data-time"
        description: "command finish time"
      created_by:
        type: "string"
        description: "API username who run the command"
      schedule_id:
        type: "string"
        format: "uuid"
        description: "Optional ID of the schedule the job was started by"
      client_ids:
        type: "array"
        items:
          type: string
        description: "list of client IDs where the command was requested to run"
      group_ids:
        type: "array"
        items:
          type: string
        description: "list of client group IDs where the command was requested to run"
      command:
        type: "string"
        description: "executed command"
      cwd:
        type: "string"
        description: "current working directory for an executable command"
      is_sudo:
        type: "boolean"
        description: "execute the command as a sudo user"
      interpreter:
        type: "string"
        description: "command interpreter that was used to execute the command"
      timeout_sec:
        type: "integer"
        description: "timeout in seconds that was used to observe the command execution on each client"
      concurrent:
        type: "boolean"
        description: "whether command was executed sequentially or concurrently on clients"
      abort_on_err:
        type: "boolean"
        description: "whether command was specified to abort or not the whole cycle, if the execution fails on some client. Not applicable if 'concurrent' is true"
      jobs:
        type: "array"
        items:
          $ref: "#/definitions/Job"
        description: "clients' jobs"
  MultiJobSummary:
    type: "object"
    properties:
      jid:
        type: "string"
        description: "multi-client job ID"
      started_at:
        type: "string"
        format: "data-time"
        description: "command finish time"
      created_by:
        type: "string"
        description: "API username who run the command"
      schedule_id:
        type: "string"
        format: "uuid"
        description: "Optional ID of the schedule the job was started by"
  UserGet:
    type: "object"
    properties:
      username:
        type: "string"
        description: "Username"
      groups:
        type: "array"
        items:
          type: string
        description: "List of groups to which the current user belongs"
      two_fa_send_to:
        type: "string"
        description: "Holds either the email or the pushover token of the user. It's used to deliver 2FA token to user when 2FA is enabled"
  UserPost:
    type: "object"
    properties:
      username:
        type: "string"
        description: "Username for the credentials pair"
      password:
        type: "string"
        description: "Password for the credentials pair"
      groups:
        type: "array"
        items:
          type: string
        description: "List of groups to which the current user belongs"
      two_fa_send_to:
        type: "string"
        description: "Holds either the email or the pushover token of the user. It's used to deliver 2FA token to user when 2FA is enabled"
  ErrorPayload:
    type: "object"
    properties:
      errors:
        type: "array"
        items:
          $ref: "#/definitions/ErrorPayloadItem"
  ErrorPayloadItem:
    type: "object"
    properties:
      code:
        type: "string"
      title:
        type: "string"
      detail:
        type: "string"
  ExecuteCmdRequest:
    description: "Request that contains a remote command to execute by rport client(s) and other related properties"
    type: "object"
    properties:
      command:
        type: "string"
        description: "remote command to execute by rport client(s). NOTE: if command limitation is enabled by an rport client then a full path command can be required to use. See https://oss.rport.io/docs/no06-command-execution.html for more details"
      cwd:
        type: "string"
        description: "current working directory where the command will be executed"
      is_sudo:
        type: "boolean"
        description: "execute the command as a sudo user"
      client_ids:
        type: "array"
        items:
          type: string
        minItems: 1
        description: "list of client IDs where to run the command"
      interpreter:
        type: "string"
        enum: [cmd, powershell]
        description: "command interpreter to use to execute the command. Is applicable only for windows clients. If not set 'cmd' is used by default"
      timeout_sec:
        type: "integer"
        description: "timeout in seconds to observe the command execution on each client separately. If not set a default timeout (60 seconds) is used"
      execute_concurrently:
        type: "boolean"
        description: "applicable only when multiple clients are specified. If true - execute the command concurrently on clients. If false - sequentially in order that is in 'client_ids'. By default is false"
      abort_on_error:
        type: "boolean"
        description: "applicable only when multiple clients are specified. Applicable only if 'execute_concurrently' is false. If true - abort the entire cycle if the execution fails on some client. By default is true"
  ExecuteScriptRequest:
    description: "Request that contains a remote script to execute by rport client(s) and other related properties"
    type: "object"
    properties:
      script:
        type: "string"
        description: "script to execute by rport client(s) in base64 format."
      cwd:
        type: "string"
        description: "current working directory where the script will be executed"
      is_sudo:
        type: "boolean"
        description: "execute the command as a sudo user"
      client_ids:
        type: "array"
        items:
          type: string
        minItems: 1
        description: "list of client IDs where to run the script"
      interpreter:
        type: "string"
        enum: [cmd, powershell, tacoscript]
        description: "command interpreter to use to execute the script. If not set 'cmd' is used by default on Windows, and '/bin/sh' on Unix. \n
        For tacoscript interpreter you should install tacoscript binary from here: https://github.com/cloudradar-monitoring/tacoscript#installation. \n
        It should also be available in the system path.\n
        Additionally, you can use interpreter aliases or full absolute paths to an interpreter of your choice (see https://oss.rport.io/docs/no14-scripts.html#scripts-execution for details)."
      timeout_sec:
        type: "integer"
        description: "timeout in seconds to observe the script execution on each client separately. If not set a default timeout (60 seconds) is used"
      execute_concurrently:
        type: "boolean"
        description: "applicable only when multiple clients are specified. If true - execute the script concurrently on clients. If false - sequentially in order that is in 'client_ids'. By default is false"
      abort_on_error:
        type: "boolean"
        description: "applicable only when multiple clients are specified. Applicable only if 'execute_concurrently' is false. If true - abort the entire cycle if the execution fails on some client. By default is true"
  LoginResponse:
    type: "object"
    description: "Response returned by `/login` endpoints"
    properties:
      token:
        type: "string"
        description: "Authorization JWT token. If 2fa or TotP is enabled, this token can only be used to verify delivered or generated code with the `/verify-2fa` endpoint. \n
        In the case with TotP, this token can be used to create the first secret with the /me/totp-secret endpoint."
      two_fa:
        type: "object"
        description: "2FA information. It's null when 2fa is disabled"
        properties:
          send_to:
            type: "string"
            description: "Recipient (email or pushover user key) that is used to send 2fa token to the user"
          delivery_method:
            type: "string"
            enum: ["email", "pushover", "totp_authenticator_app"]
            description: "Delivery method that is used to send 2fa token to the user. \n
            `totp_authenticator_app` value indicates that user has enabled time based one time passwords."
          totp_key_status:
            type: "string"
            enum: ["pending", "exists"]
            description: "If current user has generated a TotP secret key already, the result will be `existing` and `pending` otherwise"
  VaultEntryInput:
    type: "object"
    properties:
      client_id:
        type: "string"
        description: "Used to tie a document to a specific client where 0 means the document can be accessed from any client."
      required_group:
        type: "string"
        description: "if filled, users not belonging to this group are not allowed to store or read the decrypted value"
      key:
        type: "string"
        description: "[required] some string to identify the document"
      value:
        type: "string"
        description: "[required] value represents the encrypted `body` of a document. It should be provided as a plain text"
      type:
        type: "string"
        enum: &VAULT_VALUE_TYPE
          - "text"
          - "secret"
          - "markdown"
          - "string"
        description: "[required] Type of the secret value"
  VaultEntryOutputFull:
    type: "object"
    properties:
      client_id:
        type: "string"
        description: "Used to tie a document to a specific client where 0 means the document can be accessed from any client."
      required_group:
        type: "string"
        description: "if filled, users not belonging to this group are not allowed to store or read the decrypted value"
      key:
        type: "string"
        description: "some string to identify the document"
      type:
        type: "string"
        enum: *VAULT_VALUE_TYPE
        description: "Type of the secret value"
      value:
        type: "string"
        description: "decrypted value of the vault entry"
      id:
        type: "integer"
        description: "Unique internal id of a vault entry"
      created_at:
        type: "string"
        format: "data-time"
        description: "Date and time of vault entry creation"
      updated_at:
        type: "string"
        format: "data-time"
        description: "Date and time of vault entry last update"
      created_by:
        type: "string"
        description: "User name who created this vault entry"
      updated_by:
        type: "string"
        description: "User name who last updated this vault entry"
  VaultEntryOutputShort:
    type: "object"
    properties:
      client_id:
        type: "string"
        description: "Used to tie a document to a specific client where 0 means the document can be accessed from any client."
      key:
        type: "string"
        description: "some string to identify the document"
      id:
        type: "integer"
        description: "Unique internal id of a vault entry"
      created_at:
        type: "string"
        format: "data-time"
        description: "Date and time of vault entry creation"
      created_by:
        type: "string"
        description: "User name who created this vault entry"
  Script:
    type: "object"
    properties:
      name:
        type: "string"
        description: "User-friendly name of a script"
      id:
        type: "string"
        description: "unique internal identifier of a script in uuid4 format"
      created_at:
        type: "string"
        format: "data-time"
        description: "Date and time of script creation"
      created_by:
        type: "string"
        description: "User name who created this script"
      interpreter:
        type: "string"
        description: "how will the script be executed on the client, e.g. /bin/sh, cmd.exe, powershell, tacoscript"
      cwd:
        type: "string"
        description: "current working directory, where the script should be executed"
      script:
        type: "string"
        description: "text of the script"
      is_sudo:
        type: "boolean"
        description: "if true, this script will be executed as a sudo user"
  ScriptInput:
    type: "object"
    properties:
      name:
        type: "string"
        description: "[required] User-friendly name of a script"
      script:
        type: "string"
        description: "[required] text of the script"
      interpreter:
        type: "string"
        description: "how will the script be executed on the client, e.g. /bin/sh, cmd.exe, powershell, tacoscript"
      cwd:
        type: "string"
        description: "current working directory, where the script should be executed"
      is_sudo:
        type: "boolean"
        description: "if true, this script will be executed as a sudo user"
  UpdatesStatus:
    type: "object"
    properties:
      refreshed:
        type: "string"
        format: "date-time"
        description: "When was the status refreshed"
      updates_available:
        type: "integer"
        description: "Number of updates available"
      security_updates_available:
        type: "integer"
        description: "Number of security updates available"
      updates_summaries:
        type: "array"
        description: "List of available updates"
        items:
          $ref: "#/definitions/UpdateSummary"
      reboot_pending:
        type: "boolean"
        description: "Is reboot required at the moment"
      error:
        type: "string"
        description: "Error that happened when refreshing status if any"
      hint:
        type: "string"
        description: "Suggested solution to the error if any"
  UpdateSummary:
    type: "object"
    properties:
      title:
        type: "string"
        description: "Title of the update"
      description:
        type: "string"
        description: "Description of the update"
      reboot_required:
        type: "boolean"
        description: "Whether the update requires reboot"
      is_security_update:
        type: "boolean"
        description: "Whether this is a security update"
  Command:
    type: "object"
    properties:
      name:
        type: "string"
        description: "User-friendly name of a command"
      id:
        type: "string"
        description: "unique internal identifier of a command in uuid4 format"
      created_at:
        type: "string"
        format: "data-time"
        description: "Date and time of command creation"
      created_by:
        type: "string"
        description: "User name who created this command"
      updated_at:
        type: "string"
        format: "data-time"
        description: "Date and time of last command update"
      updated_by:
        type: "string"
        description: "User name who last updated this command"
      cmd:
        type: "string"
        description: "text of the command"
  CommandInput:
    type: "object"
    properties:
      name:
        type: "string"
        description: "[required] User-friendly name of a commend"
      script:
        type: "string"
        description: "[required] text of the command"
  TotP:
    type: "object"
    properties:
      secret:
        type: "string"
        description: "Secret key for time based one time password Authenticator"
      qr:
        type: "string"
        description: "base64 encoded png image (200x200px) with the QR code, needed to add a rport account in an Authenticator app"
  AuditLog:
    type: "object"
    properties:
      timestamp:
        type: "string"
        format: "date-time"
        description: "Timestamp of the action"
      username:
        type: "string"
        description: "Username of the user that initiated the action"
      remote_ip:
        type: "string"
        description: "IP of the user that initiated the action"
      application:
        type: "string"
        description: "Part of the rport that the action belongs to"
      action:
        type: "string"
        description: "Action performed"
      affected_id:
        type: "string"
        description: "ID of the entity that action was executed on"
      client_id:
        type: "string"
        description: "ID of the client that has been affected"
      client_hostname:
        type: "string"
        description: "Hostname of the client that has been affected"
      request:
        type: "string"
        description: "Json blob that was used to request the action"
      response:
        type: "string"
        description: "Json blob that was the result of the action"
  GraphMetrics:
    type: "object"
    properties:
      timestamp:
        type: "string"
        format: "date-time"
        description: "Timestamp of measurement"
      cpu_usage_percent:
        properties:
          avg:
            type: "number"
            description: "cpu_usage_percent average"
          min:
            type: "number"
            description: "cpu_usage_percent minimum"
          max:
            type: "number"
            description: "cpu_usage_percent maximum"
      memory_usage_percent:
        properties:
          avg:
            type: "number"
            description: "memory_usage_percent average"
          min:
            type: "number"
            description: "memory_usage_percent minimum"
          max:
            type: "number"
            description: "memory_usage_percent maximum"
      io_usage_percent:
        properties:
          avg:
            type: "number"
            description: "io_usage_percent average"
          min:
            type: "number"
            description: "io_usage_percent minimum"
          max:
            type: "number"
            description: "io_usage_percent maximum"
  GraphMetricsGraph:
    type: "object"
    properties:
      timestamp:
        type: "string"
        format: "date-time"
        description: "Timestamp of measurement"
      cpu_usage_percent:
        properties:
          avg:
            type: "number"
            description: "cpu_usage_percent average"
          min:
            type: "number"
            description: "cpu_usage_percent minimum"
          max:
            type: "number"
            description: "cpu_usage_percent maximum"
      memory_usage_percent:
        properties:
          avg:
            type: "number"
            description: "memory_usage_percent average"
          min:
            type: "number"
            description: "memory_usage_percent minimum"
          max:
            type: "number"
            description: "memory_usage_percent maximum"
      io_usage_percent:
        properties:
          avg:
            type: "number"
            description: "io_usage_percent average"
          min:
            type: "number"
            description: "io_usage_percent minimum"
          max:
            type: "number"
            description: "io_usage_percent maximum"
      net_usage_percent_lan:
        properties:
          in_avg:
            type: "number"
            description: "net_usage_percent_lan average input"
          in_min:
            type: "number"
            description: "net_usage_percent_lan minimum input"
          in_max:
            type: "number"
            description: "net_usage_percent_lan maximum input"
          out_avg:
            type: "number"
            description: "net_usage_percent_lan average output"
          out_min:
            type: "number"
            description: "net_usage_percent_lan minimum output"
          out_max:
            type: "number"
            description: "net_usage_percent_lan maximum output"
      net_usage_bps_lan:
        properties:
          in_avg:
            type: "number"
            description: "net_usage_bps_lan average input"
          in_min:
            type: "number"
            description: "net_usage_bps_lan minimum input"
          in_max:
            type: "number"
            description: "net_usage_bps_lan maximum input"
          out_avg:
            type: "number"
            description: "net_usage_bps_lan average output"
          out_min:
            type: "number"
            description: "net_usage_bps_lan minimum output"
          out_max:
            type: "number"
            description: "net_usage_bps_lan maximum output"
      net_usage_percent_wan:
        properties:
          in_avg:
            type: "number"
            description: "net_usage_percent_wan average input"
          in_min:
            type: "number"
            description: "net_usage_percent_wan minimum input"
          in_max:
            type: "number"
            description: "net_usage_percent_wan maximum input"
          out_avg:
            type: "number"
            description: "net_usage_percent_wan average output"
          out_min:
            type: "number"
            description: "net_usage_percent_wan minimum output"
          out_max:
            type: "number"
            description: "net_usage_percent_wan maximum output"
      net_usage_bps_wan:
        properties:
          in_avg:
            type: "number"
            description: "net_usage_bps_wan average input"
          in_min:
            type: "number"
            description: "net_usage_bps_wan minimum input"
          in_max:
            type: "number"
            description: "net_usage_bps_wan maximum input"
          out_avg:
            type: "number"
            description: "net_usage_bps_wan average output"
          out_min:
            type: "number"
            description: "net_usage_bps_wan minimum output"
          out_max:
            type: "number"
            description: "net_usage_bps_wan maximum output"
  Metrics:
    type: "object"
    properties:
      timestamp:
        type: "string"
        format: "date-time"
        description: "Timestamp of measurement"
      cpu_usage_percent:
        type: "number"
        description: "cpu_usage_percent"
      memory_usage_percent:
        type: "number"
        description: "memory_usage_percent"
      io_usage_percent:
        type: "number"
        description: "io_usage_percent"
  Mountpoints:
    type: "object"
    properties:
      timestamp:
        type: "string"
        format: "date-time"
        description: "Timestamp of measurement"
      mountpoints:
        type: "string"
        description: "JSON encoded information about mountpoints"
  Processes:
    type: "object"
    properties:
      timestamp:
        type: "string"
        format: "date-time"
        description: "Timestamp of measurement"
      processes:
        type: "string"
        description: "JSON encoded information about processes"
  StoredTunnel:
    type: "object"
    properties:
      id:
        type: "string"
        description: "unique internal identifier of a stored tunnel in uuid4 format"
        readOnly: true
      created_at:
        type: "string"
        format: "data-time"
        description: "Date and time of stored tunnel creation"
        readOnly: true
      name:
        type: "string"
        description: "Name of the stored tunnel"
      remote_ip:
        type: "string"
        description: "Remote for the stored tunnel"
      remote_port:
        type: "integer"
        description: "Remote port for the stored tunnel"
      public_port:
        type: "integer"
        description: "Public port for the stored tunnel"
      scheme:
        type: "string"
        description: "URI scheme for the stored tunnel"
      acl:
        type: "string"
        description: "ACL for the stored tunnel"
      further_options:
        type: "object"
        description: "Further options for the stored tunnel"
  Schedule:
    type: "object"
    properties:
      id:
        type: "string"
        format: "uuid"
        description: "unique internal identifier of the schedule in uuid4 format"
        readOnly: true
      created_at:
        type: "string"
        format: "data-time"
        description: "Date and time of schedule creation"
        readOnly: true
      created_by:
        type: "string"
        description: "Username of the user who created the schedule"
        readOnly: true
      name:
        type: "string"
        description: "Name of the schedule"
      schedule:
        type: "string"
        example: "* * * * *"
        description: "Schedule in the cron format"
      type:
        type: "string"
        example: "command"
        description: "'command' or 'script'"
      client_ids:
        type: "array"
        items:
          type: "string"
        description: "Client IDs that schedule will be executed on"
      group_ids:
        type: "array"
        items:
          type: "string"
        description: "Group IDs that schedule will be executed on"
      command:
        type: "string"
        description: "Command to be executed, only for type 'command'"
      script:
        type: "string"
        description: "Base64 encoded script to be executed, only for type 'script'"
      interpreter:
        type: "string"
        description: "Interpreter for schedule execution, for details on this and other params see commands or scripts"
      cwd:
        type: "string"
        description: "Cwd for schedule execution"
      is_sudo:
        type: "boolean"
        description: "Is sudo for schedule execution"
      timeout_sec:
        type: "number"
        description: "Timeout for schedule execution"
      execute_concurrently:
        type: "boolean"
        description: "Whether to execute concurrently on all clients"
      abort_on_error:
        type: "boolean"
        description: "Abort on error for schedule execution"
      overlaps:
        type: "boolean"
        description: "Whether to start another schedule execution when previous is still in progress"
  ServerUploadResponse:
    type: "object"
    properties:
      uuid:
        type: "string"
        description: "unique upload request identifier"
        readOnly: true
      filepath:
        type: "string"
        description: "Target path from input"
        readOnly: true
      size:
        type: "number"
        description: "File size in bytes"
  ClientUploadResponse:
    type: "object"
    properties:
      uuid:
        type: "string"
        description: "unique upload request identifier"
      client_id:
        type: "string"
        description: "client id"
      filepath:
        type: "string"
        description: "Target path where the file was copied to"
      size:
        type: "number"
        description: "File size in bytes"
      message:
        type: "string"
        description: "Custom message as an additional explanation to the status"
      status:
        type: "string"
        enum: ["success", "error", "ignored"]
        description: "`success` indicates successful file downloads on the client, however failures for chown and chmod operations are just reported as warnings.\n
        `error` status indicates upload failures, where message field will contain failure details. \n
        `ignored` is returned when the target file already exists and is not forced or no sync is needed"
